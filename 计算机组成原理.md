# 计算机组成原理

## 数值

### 数值表示方法

>数值表示均以8bit表示，最高位为符号位，以数值13为例。
>
>**正数的原码、反码、补码相同，仅负数有所区别。**
>
>| -\表示法 | 原码               | 反码               | 补码             |
>| -------- | ------------------ | ------------------ | ---------------- |
>| 概念     | 二进制，首位符号位 | 除符号位，原码取反 | 除符号位，反码+1 |
>| 正数     | 00001101           | 00001101           | 00001101         |
>| 负数     | 10001101           | 11110010           | 11110011         |
>


### 取值范围

> 以下均以8位有符号整数为例。
>
> **原码**：x∈[-127, 127]∩Z。最高位为符号位，剩下7位表示数值，2<sup>7</sup>-1=127。然后0分正负（00000000，10000000）。
>
> **反码**：x∈[-127, 127]∩Z。同原码。
>
> **补码**：x∈[-128, 127]∩Z。0的补码唯一。[+0]=[-0]=00000000，对比原码和反码，多出一个10000000（原码补码都是10000000）编码，用它来表示-128。

### 补码怎么来的

> 希望通过加法器来实现减法运算。补码完全符合。00001101+11110011=100000000，溢出了一位1，得到0。
>
> ```
> 补码的思想来源自计算机设计的实践：
> 1.对于一个n位寄存器，为了表示有符号数，自然的会想到用最高位0和1的不同来表示正数和负数，至于0和1谁表示负数，先按下不表；
> 2.在这种情况下,CPU中ALU的加法器实现后，自然想利用加法器实现减法；
> 3.数学上两个正数相减a-b，也可以看做a+（-b），但是如何跟硬件实现建立联系依旧没有直观认识，且听慢慢分析；
> 4.恰恰计算机的寄存器位数有限，假设有n位，那n位全1表示的数也仅仅是2^n-1，2^n就是n+1位数，此时寄存器的n位全0。这样a+(-b)得到的数值跟a+(2^n-b)在寄存器上是完全一致的，如果可以利用这一性质，减法就成功的变成了加法；
> 5.有了这个想法之后，还需要一些技巧，因为我们还需要在寄存器上表示有符号数，将上面的想法跟有符号数表示能够结合好，最终的补码具体实现就出来了；
> 6.首先对于正整数的加法器是实现出来的，所以正整数的补码保持原样就行；对于负数，高位还得正常参与运算，运算结束高位正好表示符号；
> 7.看一下高位用1表示正数合不合适，假设有一正数a，最高位1表示符号，后面n-1位表示数值a，符号位如果参与数值表示的话，这个数就是2^(n-1)+a；有一负数b，最高位0表示符号，后面n-1位表示数值b，符号位如果参与数值表示的话，这个数就是b。a-b = a + (-b) = 2^(n-1) + a + (2^n -b),好像不行；
> 8.那换过来看高位用0表示正数，假设有一正数a，后面n-1位表示数值a，符号位如果参与数值表示的话，这个数就是a；有一负数b，最高位1表示符号，后面n-1位表示数值b，符号位如果参与数值表示的话，这个数就是2^(n-1) + b。那么a – b = a + (-b) = a + (2^n – b ) = a + (2^(n-1) + 2^(n-1) - b)。如果a>b，2^(n-1)+2^(n-1)正好进位消掉了，不妨碍最到位为0，最终结果符号跟数值都正确；如果a<b,符号位2^(n-1)，数值为2^(n-1)+a-b，原码为符号位2^(n-1)，数值为b-a。所以一切就自洽了。
> ```

### 浮点数精度问题（IEEE754）

> IEEE754格式浮点数由3个部分组成，分别是：符号码`1bit`、阶码`11bit`、尾数码`52bit`（以64位为例）。
>
> 