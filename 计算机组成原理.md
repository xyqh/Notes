# 计算机组成原理

## 数值

### 数值表示方法

>数值表示均以8bit表示，最高位为符号位，以数值13为例。
>
>**正数的原码、反码、补码相同，仅负数有所区别。**
>
>| -\表示法 | 原码               | 反码               | 补码             |
>| -------- | ------------------ | ------------------ | ---------------- |
>| 概念     | 二进制，首位符号位 | 除符号位，原码取反 | 除符号位，反码+1 |
>| 正数     | 00001101           | 00001101           | 00001101         |
>| 负数     | 10001101           | 11110010           | 11110011         |
>


### 取值范围

> 以下均以8位有符号整数为例。
>
> **原码**：x∈[-127, 127]∩Z。最高位为符号位，剩下7位表示数值，2<sup>7</sup>-1=127。然后0分正负（00000000，10000000）。
>
> **反码**：x∈[-127, 127]∩Z。同原码。
>
> **补码**：x∈[-128, 127]∩Z。0的补码唯一。[+0]=[-0]=00000000，对比原码和反码，多出一个10000000（原码补码都是10000000）编码，用它来表示-128。

### 补码怎么来的

> 希望通过加法器来实现减法运算。补码完全符合。00001101+11110011=100000000，溢出了一位1，得到0。
>
> ```
> 补码的思想来源自计算机设计的实践：
> 1.对于一个n位寄存器，为了表示有符号数，自然的会想到用最高位0和1的不同来表示正数和负数，至于0和1谁表示负数，先按下不表；
> 2.在这种情况下,CPU中ALU的加法器实现后，自然想利用加法器实现减法；
> 3.数学上两个正数相减a-b，也可以看做a+（-b），但是如何跟硬件实现建立联系依旧没有直观认识，且听慢慢分析；
> 4.恰恰计算机的寄存器位数有限，假设有n位，那n位全1表示的数也仅仅是2^n-1，2^n就是n+1位数，此时寄存器的n位全0。这样a+(-b)得到的数值跟a+(2^n-b)在寄存器上是完全一致的，如果可以利用这一性质，减法就成功的变成了加法；
> 5.有了这个想法之后，还需要一些技巧，因为我们还需要在寄存器上表示有符号数，将上面的想法跟有符号数表示能够结合好，最终的补码具体实现就出来了；
> 6.首先对于正整数的加法器是实现出来的，所以正整数的补码保持原样就行；对于负数，高位还得正常参与运算，运算结束高位正好表示符号；
> 7.看一下高位用1表示正数合不合适，假设有一正数a，最高位1表示符号，后面n-1位表示数值a，符号位如果参与数值表示的话，这个数就是2^(n-1)+a；有一负数b，最高位0表示符号，后面n-1位表示数值b，符号位如果参与数值表示的话，这个数就是b。a-b = a + (-b) = 2^(n-1) + a + (2^n -b),好像不行；
> 8.那换过来看高位用0表示正数，假设有一正数a，后面n-1位表示数值a，符号位如果参与数值表示的话，这个数就是a；有一负数b，最高位1表示符号，后面n-1位表示数值b，符号位如果参与数值表示的话，这个数就是2^(n-1) + b。那么a – b = a + (-b) = a + (2^n – b ) = a + (2^(n-1) + 2^(n-1) - b)。如果a>b，2^(n-1)+2^(n-1)正好进位消掉了，不妨碍最到位为0，最终结果符号跟数值都正确；如果a<b,符号位2^(n-1)，数值为2^(n-1)+a-b，原码为符号位2^(n-1)，数值为b-a。所以一切就自洽了。
> ```

### 浮点数（IEEE 754）

> IEEE 754格式浮点数由3个部分组成，分别是：符号码、阶码、尾数码。
>
> | 类型                        | 符号码（sign） | 阶码（exponent） | 尾数码（fraction） | 总位数 | 偏置值         |
> | --------------------------- | -------------- | ---------------- | ------------------ | ------ | -------------- |
> | 短浮点数（float）           | 1              | 8                | 23                 | 32     | 0x7FH/127D     |
> | 长浮点数（double）          | 1              | 11               | 52                 | 64     | 0x3FFH/1023D   |
> | 临时短浮点数（long double） | 1              | 15               | 64                 | 80     | 0x3FFFH/16383D |
>
> **符号码sign**：0正1负；
>
> **阶码e**：在IEEE 754浮点数标准中，阶码使用移码表示的，移码的定义：移码=真值+偏置值；
>
> **尾数码fraction**：尾数部分（原码表示）
>
> **计算**：
> $$
> (-1)^{sign}\times 2^{e-1023}\times 1.fraction
> $$
>
> $$
> (-1)^{sign}\sum_{i=1}^{52}b_{52-i}2^{-i}\times 2^{e-1023}
> $$
>
> 关于指数部分的计算：已知11位无符号整数的表示范围为：[0, 2047]，e-1023∈[-1023, 1024]，实际能取到的范围是[-1022, 1023]。原因如下：
>
> 1. 阶码真值为-1023
>
>    1. 当阶码全为0，尾数不全为0，表示非规格化小数，用来表示比绝对值还要小的数。此时尾数码隐含的最高位不是1，而是0；阶码真值固定为-1022而不是-1023。
>       $$
>       (-1)^{sign}\times 2^{1-1023}\times 0.fraction= (-1)^{sign}\times 2^{-1022}\times 0.fraction
>       $$
>
>    2. 当阶码全为0，尾数全为0，表示真值+/-0。
>
> 2. 阶码真值为1024
>
>    1. 当阶码全为1，尾数不全为0，表示非数值NaN（Not a Number）。
>    2. 当阶码全为1，尾数全为0，表示正负无穷+/-无穷。
>
> **规格数**：用于表示最常见的数值，但不能表示0和非常接近0的数。
>
> **非规格数**：用于表示0，以及非常接近0的数。
>
> **特殊数**：用于表示无穷和NaN。