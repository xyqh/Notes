# 计算机图形学

## 数学基础

### 向量点积和叉积的几何意义

> 点乘：用来计算两个向量的夹角，以及b向量在a向量上的投影
>
> 叉乘：可以得到这两个向量所在平面的法向量（有向面积），该向量的模等于这两个向量组成的平行四边形的面积

### 如何判断点在三角心内

> **内角和**：
>
> > 连接点P和三角形的三个顶点得到三条线段PA，PB和PC，求出这三条线段与三角形各边的夹角，
> > 如果所有夹角之和为180度，那么点P在三角形内，否则不在，此法直观，但效率低下。
>
> **同向法**：
>
> > 对于三角形的三个顶点ABC和点P，计算向量AP，AB的叉乘，BP，BC的叉乘，CP，CA的叉乘三者大小一致。
>
> **重心法**：
>
> > 三角形的三个点在同一个平面上，如果选中其中一个点，其他两个点不过是相对该点的位移而已，
> > 比如选择点A作为起点，那么点B相当于在AB方向移动一段距离得到，而点C相当于在AC方向移动一段距离得到。
> > 所以对于平面内任意一点，都可以由如下方程来表示
> > P = A +  u * (C – A) + v * (B - A) // 方程1
> > 如果系数u或v为负值，那么相当于朝相反的方向移动，即BA或CA方向。
> > 那么如果想让P位于三角形ABC内部，u和v必须满足什么条件呢？有如下三个条件
> > u >= 0
> > v >= 0
> > u + v <= 1

### 如何判断一个多边形是凸多边形

> 1）角度法：
> 判断每个顶点所对应的内角是否小于180度，如果小于180度，则是凸的，如果大于180度，则是凹多边形。
> 2）凸包法：
> 这种方法首先计算这个多边形的凸包，关于凸包的定义在此不再赘述，首先可以肯定的是凸包肯定是一个凸多边形。如果计算出来的凸多边形和原始多边形的点数一样多，那就说明此多边形时凸多边形，否则就是凹多边形。
> 3）顶点凹凸性法
> 利用以当前顶点为中心的矢量叉乘或者计算三角形的有符号面积判断多边形的方向以及当前顶点的凹凸性。
> 假设当前连续的三个顶点分别是P1，P2，P3。计算向量P1P2,P2P3的叉乘，也可以计算三角形P1P2P3的面积，得到的结果如果大于0，则表示P3点在线段P1和P2的左侧，多边形的顶点是逆时针序列。然后依次计算下一个前后所组成向量的叉乘，如果在计算时，出现负值，则此多边形时凹多边形，如果所有顶点计算完毕，其结果都是大于0，则多边形时凸多边形。
> 4）辛普森面积法
> 利用待判别的顶点以及前后两个顶点所组成的三角形，利用辛普森公式计算其面积，如果此三角形面积与整个多边形面积符号相同，那么这个顶点是凸的；如果此三角形面积与整个多边形面积符号不同，那么这个顶点是凹的，即整个多边形也是凹多边形。

### 叉乘求多边形的面积

> 通过叉乘求多边形的面积是通过矢量的方法来实现的。假设多边形的顶点按照顺时针或逆时针的顺序给出，可以使用以下步骤：
>
> 1. **定义多边形的顶点：** 假设多边形的顶点为 \( P_1, P_2, P_3, \ldots, P_n \)，这些点按照顺时针或逆时针的顺序给出。
>
> 2. **计算相邻边的矢量：** 对于每一对相邻的顶点 \( P_i \) 和 \( P_{i+1} \)，计算矢量 \( \vec{v_i} = P_{i+1} - P_i \)。
>
> 3. **计算叉乘：** 对于相邻的矢量 \( \vec{v_i} \) 和 \( \vec{v_{i+1}} \)，计算它们的叉乘 \( \vec{v_i} \times \vec{v_{i+1}} \)。
>
> 4. **累加叉乘结果：** 将所有的叉乘结果累加起来。
>
> 5. **取绝对值并除以2：** 最终的面积是取上述结果的绝对值并除以2。
>
> 数学上，这个过程可以用如下的公式表示：
>
> \[ \text{Area} = \frac{1}{2} \left| \sum_{i=1}^{n-1} (x_iy_{i+1} - x_{i+1}y_i) + (x_ny_1 - x_1y_n) \right| \]
>
> 其中，\( (x_i, y_i) \) 是多边形的第 \( i \) 个顶点的坐标。
>
> 需要注意的是，这个公式假设多边形的顶点是按照顺时针或逆时针的顺序给出的。如果顶点的顺序是混乱的，可能会导致计算出的面积方向不正确。通常，我们会在计算前确保多边形的顶点按照一定的规则有序。

### 空间两直线求距离

> 空间两直线之间的位置关系主要可以分为： 重合， 平行， 相交， 异面。
> 异面：首先将直线方程化为对称式，得到其方向向量n1=（a1,b1,c1),n2=(a2,b2,c2).
> 	  再将两向量叉乘得到其公垂向量N=（x,y,z）,在两直线上分别选取点A,B(任意)，得到向量AB，
>       求向量AB在向量N方向的投影即为两异面直线间的距离了（就是最短距离啦）
> 	  最短距离的求法：d=|向量N*向量AB|/|向量N|（上面是两向量的数量积，下面是取模）。
> 平行：两平行直线
> 	  L1:(x-x1)/m=(y-y1)/n=(z-z1)/p,L2:(x-x2)/m=(y-y2)/n=(z-z2)/p,
> 	  记 M1(x1,y1,z1),M2(x2,y2,z2),直线方向向量 s = {m,n,p}
> 	  则 记向量 M1M2 = {x2-x1,y2-y1,z2-z1} = {a,b,c}
> 	  故得平行线间的距离
> 	  d = | M1M2×s | / |s|=√[(bp-cn)^2+(cm-ap)^2+(an-bm)^2]/√(m^2+n^2+p^2）

### 空间点到空间三角形的最近距离

> 平面定义：空间中的一点P与法线n，所有在该平面上的点 X 都满足：
> n⋅(X−P)=0
> 求解：空间中的点 Q到平面的最近点：
> 1. 使用点 Q减去点 P，然后与平面的法线进行 Dot点积运算，求出了点到平面的距离 t。
> 2. 利用点 Q减去 t 乘于法线 n，则求出了平面上的点 R。

### 什么是齐次坐标

> 原因：在欧氏几何空间，同一平面的两条平行线不能相交。然而，在透视空间里面，两条平行线可以相交。
> 笛卡尔坐标系下（1，2）的齐次坐标可以表示为（1，2，1），如果点（1，2）移动到无限远处，在笛卡尔坐标下它变为
> (∞,∞)，然后它的齐次坐标表示为（1，2，0），因为(1/0, 2/0) = (∞,∞)，
> 为什么叫齐次坐标？
> 我们把齐次坐标转化为笛卡尔坐标的方法是前面n-1个坐标分量分别除以最后一个分量即可。
> 齐次坐标好处：齐次坐标可以表示无穷远处的点， 更简洁的表达欧氏空间变换，能够区分一个向量和一个点。
> (1)从普通坐标转换成齐次坐标时
> 如果(x,y,z)是个点，则变为(x,y,z,1);
> 如果(x,y,z)是个向量，则变为(x,y,z,0)
> (2)从齐次坐标转换成普通坐标时
> 如果是(x,y,z,1)，则知道它是个点，变成(x,y,z);
> 如果是(x,y,z,0)，则知道它是个向量，仍然变成(x,y,z)

### MVP变换，其他变换

> Model matrix：对象坐标系->世界坐标系
> View martirx：世界坐标系->眼坐标系
> Projection martrix：眼坐标系->裁剪坐标系
> 透视除法：裁剪坐标系->NDC坐标系device=clip<sub>xyz</sub>/clip<sub>w</sub>

### 如何表示一个平面

> 截距式
> 设平面方程为Ax+By+Cz+D=0,若D不等于0，取a=-D/A,b=-D/B,c=-D/C,则得平面的截距式方程：x/a+y/b+z/c=1
> 它与三坐标轴的交点分别为P(a,0,0),Q(0,b,0),R(0,0,c)，其中，a,b,c依次称为该平面在x,y,z轴上的截距。
>
> 点法式
> n为平面的法向量，n=(A,B,C),M,M’为平面上任意两点，则有n·MM’=0, MM’=(x-x0,y-y0,z-z0)，
> 从而得平面的点法式方程：A(x-x0)+B(y-y0)+C(z-z0)=0
>
> 一般式
> Ax+By+Cz+d=0

### 最小二乘法

> 最小二乘法（又称最小平方法）是一种数学优化技术。
> 它通过最小化误差（真实目标对象与拟合目标对象的差）的平方和寻找数据的最佳函数匹配。
> 利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小.
>
> 以下是线性回归例子：
>
> ![img_cg_1](.\images\img_cg_1.png)

### 欧拉角和四元数

> 关于万向锁问题，大前提是三个轴有嵌套关系，即Z包含Y包含X，当Z轴转动时会带动Y和X一起动，于是当旋转Y轴时有可能将X轴带到与Z轴重合，丢失了一个旋转角度，因此产生了万向锁。
>
> 欧拉角的表示直观易理解，但不能实现平滑插值。
>
> 四元数可以避免万向锁，提供平滑插值（球面线性插值），只需一个四元数即可执行绕任意过原点的向量的旋转。但是比欧拉角复杂且理解更困难。
>
> 与复数类似。四元数是对于基{1,i,j,k}的线性组合。
>
> 且unity的Rotate表面上看是欧拉角旋转，底层都是转成四元数的。

### 给定点集求凸包

> 1. 找到凸包最左下角的顶点作为起点start，如上图中的p0。寻找方法非常简单，找到点集中纵坐标最小的点，如果有多个点，再在其中找到横坐标最小的点。
>
> 2. 将点集整体平移至p0位于原点。
>
> 3. 极角排序：以p0为极点，p0向有方向为极轴，计算其余各点相对p0的极角，并按极角大小对各点进行排序（当极角相同时，距离p0较近的点排在前面），由排序结果可以知道第一个点p1和最后一个点p8一定是凸包上的点。
>
>    ![img_cg_2](.\images\img_cg_2.png)
>
> 4. 初始化一个栈，起点p0入栈，步骤3极角排序后得到的结果存于队列中，排最前面的一个点p1出队，然后入栈。
>
> 5. 当结果队列不为空时，队首元素出队作为当前点。根据如下条件判断该点能否入栈
>
>    ```
>    if(栈内元素个数＜2)
>    {
>    	入栈
>    	取队列内下一个元素作为当前点
>    }
>    else
>    {
>    	取栈顶两个元素连成有向向量 Vector：s.top-1 → s.top
>    	根据叉乘的结果的正负判断当前点与 Vector 的位置关系
>    	if(当前点在 Vector 的左边或在 Vector 上)
>    	{
>    		入栈
>    		取队列内下一个元素作为当前点
>    	}
>    	else
>    	{
>    		当前点不会入栈，栈顶元素出栈，且重新执行判断当前点能否入栈的过程
>    	}
>    }
>    ```
>
> 6. 当结果队列为空时，结束凸包算法，栈内的点就是凸包的顶点，且从栈底到栈顶，沿着凸包按逆时针顺序排列

### 什么是齐次坐标

> 齐次坐标是一种在计算机图形学和计算机图像处理中广泛使用的坐标系统。它引入了一个额外的坐标，通常被称为齐次坐标 \(w\)，用来表示欧几里得坐标系中的点。在二维齐次坐标中，一个点的齐次坐标为 \((x, y, w)\)，而在三维中为 \((x, y, z, w)\)。
>
> 齐次坐标的优势在于它简化了许多数学运算，尤其是仿射变换和投影。通过引入齐次坐标，可以使用矩阵乘法来表示平移、旋转、缩放和投影等变换，这些变换都可以通过同一种方式来表示，从而简化了计算过程。
>
> 在齐次坐标系统中，欧几里得坐标可以通过齐次坐标除以 \(w\) 得到。具体来说，如果一个点的齐次坐标是 \((x, y, w)\)，那么它的欧几里得坐标为 \((x/w, y/w)\)。这种表示方式的一个优势是，当 \(w\) 为1时，齐次坐标就等同于欧几里得坐标。
>
> 在计算机图形学中，齐次坐标通常用于表示变换矩阵的乘法。例如，在进行平移、旋转、缩放等操作时，可以通过将这些操作表示为矩阵，并通过矩阵乘法来对齐次坐标进行变换。这样的表达方式简化了图形变换的计算，并提高了计算效率。

### 已知法线向量和入射向量求反射向量

> ![img_cg_3](.\images\img_cg_3.png)
>
> **R** = **I** - 2(**I** · **N**)**N**

### 视锥体如何定义

> **透视投影的视锥体**：
>
> > 透视投影的视锥体通常由一个视点（摄像机位置）和一个近平面、远平面之间的四边形截面定义。视锥体的定义可以通过以下参数：
> >
> > **视点（Eye/Camera Position）：** 视锥体的顶点，即摄像机的位置。
> >
> > **近平面（Near Plane）和远平面（Far Plane）：** 视锥体的截面。这两个平面之间的空间将被投影到屏幕上。通常，近平面靠近摄像机，而远平面则离摄像机较远。
> >
> > **视场角（Field of View）：** 视点的视线方向与近平面和远平面之间的夹角。
> >
> > **纵横比（Aspect Ratio）：** 屏幕宽度与高度的比例。
>
> **正交投影的视锥体**：
>
> > 正交投影的视锥体是一个长方体，其定义包括：
> >
> > - **左、右、上、下、近、远六个平面：** 这些平面定义了正交投影视锥体的边界。
> >
> > 正交投影的视锥体中，物体在深度方向上不会有透视效果，即物体在不同深度上的大小不会改变。

### 在一个变换矩阵中旋转缩放平移的顺序

> 一般是先缩放，再旋转，最后平移。







## 渲染管线

### 渲染管线流程

> 应用阶段->几何阶段->光栅化阶段->逐片元操作->后处理->交换framebuffer到幕前，幕后的拿来做下一帧的渲染

### 应用阶段

> #### 准备数据
>
> > **基本场景数据**：
> >
> > 物体变换数据（位置、旋转、缩放等），物体网格数据（顶点数据、uv贴图等）
> >
> > **摄像机数据**：
> >
> > 位置，方向，远近裁剪屏幕，正交/透视（fov），视口比例/尺寸等
> >
> > **光源及阴影数据**：
> >
> > 光源类型（方向光、点光源、聚光灯等），方向光（颜色、方向），点光源（颜色、位置、半径），聚光灯（颜色、位置、方向、内外圆锥角），是否需要阴影（判断该光源可见范围内是否有可投射阴影的物体），阴影参数（对应光源序号、阴影强度、级联参数、深度偏移、近平面偏移）
> >
> > **其他全局数据**
>
> #### 粗粒度剔除
>
> > 将不可见物体剔除
>
> #### **渲染设置**
>
> > 合批方式，绘制顺序（相对摄像机的距离、材质renderqueue、uicanvas、其他方式），渲染目标（Framebuffer，render texture），渲染模式（前向渲染、延迟渲染）

### 几何阶段

> **顶点着色**：
>
> > 视图变换：模型变换->视图变换->投影变换->视口变换->透视除法
> >
> > 顶点着色
>
> **可选顶点处理**：
>
> > 曲面细分（可选）：
> >
> > 作用：使几何体拥有更丰富的网格细节，而使其更加平滑，提高视觉效果。
> >
> > 原因：实现lod；物理模拟和动画特效，在低模网格上执行物理模拟和动画特效的计算，以降低开销；节约内存，保存时采用低模网格节省资源，然后根据需要丰富网格细节。
> >
> > 方式：Loop细分和Catmull-Clark细分。
> >
> > 几何着色器（可选）：
> >
> > 顶点着色器以顶点数据作为输入数据，而几何着色器则以完整的图元(Primitive)作为输入数据。例如，以三角形的三个顶点作为输入，然后输出对应的图元。与顶点着色器不能销毁或创建顶点不同，几何着色器的主要亮点就是可以创建或销毁几何图元，此功能让GPU可以实现一些有趣的效果。可以对几何图元进行拓展剔除变换和生成。
> >
> > 常见的有：法线可视化、动态几何体形成、画有粗细的线等。
>
> **裁剪**：
>
> > CVV（Canonical View Volume）规范视体积的缩写，在裁剪测试中检查顶点是否在CVV内，并进行相应的裁剪操作
> >
> > 正面或背面剔除（可配置）
>
> **屏幕映射**：
>
> > 从连续到离散
> >
> > 坐标系差异（OpenGL/DX）

### 光栅化阶段

> **三角形设置**：
>
> > 已知三角形顶点，需要计算三角形的边界信息。
> >
> > 1. 顶点排序，三角形的顶点根据其屏幕空间坐标的顺时针或逆时针排序。一种常见的方法是通过叉乘判断顶点的排序方向，从而确定三角形的正面和背面。
> > 2. 背面剔除：根据三角形的朝向，执行背面剔除操作。
>
> **三角形遍历**：
>
> > 1. 计算三角形覆盖的所有像素。
> > 2. 用三个顶点对每一个被覆盖的像素进行插值，然后得到像素对应片元的数据（这一操作并不影响最终的屏幕呈现，只是用来标识三角形网格是怎么覆盖每个像素的）。
> > 3. 重复1-2直至所有三角形遍历完成。
>
> **抗锯齿**：
>
> > **SSAA（super-sampling anti-aliasing）**：
> >
> > > 渲染到一个放大n倍的buffer下进行采样，最后再下采样
> >
> > **MSAA（multi-sampling anti-aliasing）**：
> >
> > > 和ssaa类似，都有多个次像素点，但是只会着色一次
> >
> > **FXAA**：
> >
> > > 后处理阶段。快速近似抗锯齿，通过提取像素界面周围的颜色信息并完成混合来消除高对比度界面所产生的锯齿。但是FXAA将像素的提取和混合过程交由GPU内的ALU来执行，因此其所占用的显存带宽要大大低于传统的MSAA。
> >
> > **TXAA**：
> >
> > > 后处理阶段的抗锯齿，用前一帧的来采样。

### 逐片元操作

> 片元着色：对三角形中任意像素点做线性插值得到对应颜色。
>
> 颜色混合：
>
> > 透明度测试：透明度低于阈值的片元被舍弃。
> >
> > 模板测试：一般用来实现特殊效果如镂空、描边、阴影等。原理和深度测试类似。
> >
> > 深度测试：片元的深度和对应深度缓冲中的深度值做比较。深度缓冲默认有初始值最大值，当前片元深度值<或<=缓冲中的深度值时（一般情况，可配置，深度大离摄像机远），渲染该片元并更新缓冲中的深度值。
> >
> > 混合：不透明取最前方；透明的看混合方程。混合=混合因子+混合操作，可配置。

### 片元是什么

> 三角形遍历阶段将会检查每个像素是否被一个三角网格所覆盖，如果被覆盖的话，就会生成一个片元。因此，片元是渲染管线中的一个阶段产物，它包含了在屏幕上绘制一个像素所需的所有信息。片元可以看作是像素的候选者，它包含了颜色、深度、法线等信息，但可能还需要经过一些测试（如深度测试、模板测试等）来确定最终是否会在屏幕上显示为一个像素。在着色器（特别是片元着色器）中，你可以对片元进行处理，设置它的最终颜色和其他属性。



## 其他

### 深度测试过程、透明非透明物体渲染顺序？ 如何确定这些物体渲染顺序？

> 深度测试（Depth Testing）是在图形渲染中用于确定哪些像素应该被绘制的技术。在深度测试中，每个像素都与深度缓冲中的值进行比较，决定是否覆盖先前绘制的像素。透明和非透明物体的渲染顺序通常需要特殊处理，因为透明物体的渲染与深度测试之间存在复杂的关系。
>
> ### 深度测试过程：
>
> 1. **深度缓冲清除：** 在渲染场景之前，深度缓冲被清除为一个大值，表示初始的深度值。
>
> 2. **深度测试：** 在绘制每个像素之前，深度测试将新的深度值与深度缓冲中的值进行比较。如果新的深度值小于深度缓冲中的值，表示新的像素位于先前绘制的物体之前，那么新的像素将被绘制，否则将被丢弃。
>
> ### 透明非透明物体渲染顺序：
>
> 在渲染透明和非透明物体时，通常需要按照正确的顺序渲染它们，以确保透明物体正确地叠加在非透明物体后面。这个过程通常包括以下步骤：
>
> 1. **渲染不透明物体：** 首先，按照从前向后的顺序渲染不透明物体。这是因为不透明物体的渲染不受到后续物体的影响，它们按照深度顺序渲染即可。
>
> 2. **关闭深度写入：** 在渲染透明物体之前，通常会关闭深度写入。这意味着后续的像素不会修改深度缓冲，因此透明物体的深度值不会影响到已经绘制的不透明物体。
>
> 3. **按照远到近的顺序渲染透明物体：** 透明物体通常需要按照远到近的顺序进行渲染，以确保正确的混合效果。深度测试此时只用于决定是否覆盖已有像素，而不再用于确定渲染顺序。
>
> ### 确定物体渲染顺序：
>
> 1. **手动排序：** 对于静态场景，可以手动确定物体的渲染顺序。这种方法适用于相对简单的场景。
>
> 2. **远近平面排序：** 对于相机视锥体内的物体，可以通过与相机视锥体的近平面和远平面的交点进行排序，从而确保远的物体在前，近的物体在后。
>
> 3. **透明物体排序：** 对于透明物体，可以使用视点到物体中心的距离进行排序，或者使用与相机视线的夹角。这有助于确保按照远到近的顺序进行渲染。
>
> 4. **使用深度缓冲：** 对于不透明物体，深度缓冲提供了自动的深度排序。但对于透明物体，深度缓冲通常不足以解决问题，因此需要其他手段进行排序。
>
> 总的来说，深度测试用于解决物体的遮挡关系，而透明物体的渲染顺序则通常需要特殊处理。手动排序和使用视点和深度信息是常见的方法。

### 了解compute shader吗 

> 计算着色器是一种在图形渲染管线中的着色器类型，专门用于在GPU上执行通用计算任务，而不仅仅是图形渲染。
>
> 以下是关于计算着色器的一些要点：
>
> 1. **用途：** 计算着色器通常用于执行大规模的数据并行计算，例如物理模拟、图像处理、科学计算、数据处理等。它们提供了一种在GPU上执行通用计算任务的灵活手段。
>
> 2. **独立于图形渲染：** 不同于顶点、片元或几何着色器，计算着色器是独立于图形渲染的。它们不处理图形的可见性或颜色输出，而是专注于大规模数据并行计算。
>
> 3. **输入和输出：** 计算着色器通常接收输入缓冲区（例如纹理或结构化缓冲区），并在GPU上并行处理每个元素。输出可以写入到另一个缓冲区。
>
> 4. **语言：** 计算着色器通常使用专门的语言编写，如HLSL（High-Level Shading Language）或GLSL（OpenGL Shading Language）。这些语言提供了对GPU硬件的直接访问，并提供了执行通用计算所需的功能。
>
> 5. **并行性：** 计算着色器是高度并行的。它们被设计为同时处理多个数据元素，从而利用GPU的并行计算能力。
>
> 6. **硬件支持：** 计算着色器的支持已经成为现代GPU架构的标准特性。它们广泛应用于科学计算、深度学习、图形学以外的领域。
>
> 7. **框架集成：** 计算着色器通常被集成到图形API的框架中，例如DirectX和OpenGL。它们也常用于计算框架，如CUDA和OpenCL。
>
> 使用计算着色器可以极大地加速许多需要并行处理的任务，因为GPU的设计是为了在大量数据上高效执行计算。这使得计算着色器在图形学、科学计算和深度学习等领域都变得非常有用。

### 什么情况下fs的执行次数会小于vs的执行次数

> 在图形渲染中，通常情况下，片元着色器（Fragment Shader，FS）的执行次数会大于顶点着色器（Vertex Shader，VS）的执行次数。这是因为片元着色器在屏幕上每个像素都会执行，而顶点着色器在渲染过程中的执行频率相对较低。
>
> 然而，有一些特殊的情况下，片元着色器的执行次数可能会小于顶点着色器的执行次数。以下是一些可能的情况：
>
> 1. **裁剪和遮挡：** 当使用裁剪和遮挡技术时，可能会在顶点着色器阶段将某些顶点剔除，从而减少片元着色器的执行次数。例如，如果一个三角形完全位于屏幕之外，那么它的片元就不会被渲染。
>
> 2. **多重采样：** 在某些情况下，使用多重采样技术可以减少片元着色器的执行次数。多重采样允许在一个像素上执行多次片元着色，然后根据采样点的覆盖情况来确定最终像素的颜色。这样可以减少片元着色器的执行次数。
>
> 3. **Mipmap 级别选择：** 当使用纹理贴图时，渲染引擎可能会根据距离相机的远近选择不同的 Mipmap 级别。在某些情况下，低分辨率的 Mipmap 级别可能减少了片元着色器的执行次数。
>
> 总体而言，减少片元着色器执行次数的情况相对较少，而大多数情况下片元着色器会在每个屏幕像素上执行，执行频率高于顶点着色器。

### 了解NPR吗

> NPR 指的是非真实感渲染（Non-Photorealistic Rendering）。它是一种图形学领域的渲染技术，目的是产生一些艺术性或者卡通风格的图像，而不是真实世界的照片般的图像。NPR 的应用领域非常广泛，包括动画电影、电子游戏、科学可视化等。
>
> 以下是一些常见的 NPR 技术和风格：
>
> 1. **图像边缘检测：** 通过强调图像中的边缘，可以使图像看起来更具卡通风格。一些常用的技术包括 Sobel 算子、Canny 边缘检测等。
>
> 2. **扁平着色：** 将光照模型简化为一些块状或平面的颜色，而不考虑光照的细节。这样的效果通常使图像看起来更加扁平化。
>
> 3. **半色调：** 使用半色调效果，即将图像分成一系列颜色区域，每个区域都由一种颜色表示，而不是使用连续的颜色渐变。
>
> 4. **画笔渲染：** 模拟手绘画笔的效果，包括颜色涂抹、画笔笔触等。这样的效果通常用于创建艺术性强烈的图像。
>
> 5. **油画效果：** 模拟油画的质感和笔触，使图像看起来更加艺术化。
>
> 6. **图像分割：** 将图像分割成不同的区域，每个区域应用不同的渲染效果。这可以用于创建抽象或风格化的图像。
>
> 7. **Toon Shading：** 一种特殊的着色技术，模拟卡通或动漫的图像效果，通常通过使用有限的颜色级别和高光反射来实现。
>
> 8. **实时风格迁移：** 使用神经网络等技术，将图像转换成特定艺术风格，例如著名画家的画风。
>
> NPR 技术的发展旨在超越传统的真实感渲染，为图形艺术家和设计师提供更多创作的自由度。

### 卡通渲染的方法

> 卡通渲染是一种非真实感渲染技术，目的是模拟或强调卡通风格的图像效果。下面是一些常见的卡通渲染方法：
>
> 1. **Toon Shading（卡通着色）：** 这是最经典的卡通渲染方法之一。Toon Shading 将光照模型简化为几个离散的颜色级别，通常使用平滑的颜色渐变，而不是连续的渐变。这种方法经常使用边缘检测来强调物体的边缘，使其看起来更加卡通化。
>
> 2. **Cel Shading（卡通渲染）：** 与 Toon Shading 类似，Cel Shading 也使用离散的颜色级别，但它通常会在色调之间增加硬边缘，以进一步强调卡通风格。
>
> 3. **边缘检测：** 在卡通渲染中，强调物体的边缘是很重要的。一些技术，比如 Sobel 算子或 Canny 边缘检测，可以用于检测图像中的边缘。
>
> 4. **扁平着色：** 卡通风格通常忽略真实世界的光照模型，将光照简化为平面着色。这意味着物体的各个部分会以相同的颜色着色，而不考虑光照的影响。
>
> 5. **纹理贴图：** 使用简单的平面颜色着色之外，你还可以使用卡通风格的纹理，例如使用简化的纹理图案来代替真实的纹理。
>
> 6. **实时风格迁移：** 这是一种使用深度学习技术的方法，可以将图像转换成特定艺术家的风格，包括卡通风格。
>
> 7. **轮廓着色：** 在轮廓着色中，边缘被强调并且可以使用不同的颜色进行填充。这样可以使得物体在视觉上更加突出。
>
> 8. **油画效果：** 模拟油画效果，通过使用笔触和颜料的效果，使图像看起来更具艺术感。
>
> 实现卡通渲染的具体方法取决于你的需求和使用的渲染引擎。许多图形引擎和渲染框架都提供了卡通渲染效果的实现或者可以通过自定义着色器来实现。

### 描边方法了解哪些？区别？优缺点

> 来自：https://zhuanlan.zhihu.com/p/446473650
>
> ### **Procedural Geometry Silhouetting**：
>
> > 中文一般称为“法线外扩法”、“背面膨胀法”，日文资料中会称作「背面法」，它们指的是同一个技术。
> >
> > 算法非常简单，因此即便是到了可编程渲染管线年代时仍然采用同样的算法——直接在Vertex Shader中对顶点进行操作。不必再像《XIII》一样创建稍微大一些的模型。算法分为两个Pass，具体如下：
> >
> > - 第一个Pass：正常绘制物体
> > - 第二个Pass：
> >   - Vertex Shader阶段将顶点向顶点法线方向移动一定距离
> >   - Rasterization阶段将Cull Mode设置为Cull Front
> >
> > 问题1：出现了意料之外的描边，或者不想在某个地方看到描边
> >
> > > 由于模型的复杂性（尤其是头发这种有复杂凹凸关系的模型），在使用法线外扩法时往往会出现不太想要的描边。为了防止出现这些不受欢迎的描边，可以给每个顶点设置一个Depth Bias值、将顶点埋进里面从而被遮挡住。
> >
> > 问题2：描边出现断裂，或者出现了看起来很奇怪的描边
> >
> > > 出现这个问题的原因是每个面的法线都是垂直于平面的，所以在边角处就连接不上了。一般这种问题的解决方案是另外存储一套平滑法线。具体做法是计算与该点位置相同的所有点的法线的平均值并存储在顶点上。
> >
> > 问题3：我想给线条注入灵魂！想要有粗细变化，还想要有颜色！
> >
> > > 由于法线外扩法是基于模型的，所以实际上对线条还是有较高的自由度来控制。如果想要做到有粗细变化的描边，可以参考罪恶装备Xrd中将粗细变化的数值写入顶点色当中。实际上就是一个外扩系数：数值越大，越向外扩，线条越粗。
>
> ### **Fresnel Equation**
>
> > 也可以稍微运用Fresnel Equation（菲涅尔方程）来实现类似描边的效果，上图使用了UE4材质自带的Fresnel节点。通常描边就发生在物体的边缘上，而越靠近边缘时顶点法线与摄像机向量间的点乘越靠近0，因此可以判断这个点乘结果来判断是否为描边。
> >
> > 但是这个效果太不稳定了，尤其是平面会出现大片的描边，因为平面上的法线都一样。这种方法更适合用于那些球形物体。
>
> ### **Geometry Shader/Compute Shader**
>
> > 上面两种方式都只能在边缘处渲染出描边，但是无论是漫画还是动画中，那些非边缘处的描边也是一个提升风格化质感的一个重要影响因素。对于这种描边，米哈游在Unite2018中分享了一种基于Geometry Shader的做法。
> >
> > 按照原文中的说法，他们首先通过预处理的方式提取那些感兴趣的边缘，保存到额外的Mesh资源上。在渲染时通过Geometry Shader将这些边缘绘制出来。
> >
> > 顺着这个思路、不把问题想复杂的话，那么原文所指的额外的Mesh资源本身就是Line而不是Triangle的集合，那么可以直接Draw这个Mesh就能得到渲染的边、而不用靠Geometry。但是Unity好像也只能绘制三角面片，所以猜测是把是否为边的信息标记在顶点上、在Geometry Shader中判断这个信息从原来的三角面片输入降维输出边。
> >
> > 另外不确定Unity的SRP能不能指定Topology Type，如果可以的话同样可以指定为Line的Topology Type来避免使用Geometry Shader。不过考虑到崩崩崩是2016年发行的游戏、当时SRP还不成熟，所以也用不了SRP。
> >
> > 不过不管怎么说，出于性能跟兼容性问题还是尽量避免使用Geometry Shader的好。但是这种思路还是非常不错的，因为这种方式对线条的控制也有很高的自由度，并且相比起法线外扩法可以创造更多细节。而且目前Compute Shader已经相当成熟且普及了，所以考虑用Compute Shader＋软光栅的方式说不定也是一条走得通的道路。

### 兰伯特光照模型与半兰伯特光照模型

> 漫反射只与入射光与顶点/平面法线有关。
>
> diffuse = I*cosθ
>
> 其中I为入射光强度
>
> cosθ为光源方向和顶点法线的余弦，也就是两者的点乘，这个值越大，则cosθ越大
>
> 但是如果光在物体背面，则这个值为负数，于是就归为0就可以了
>
> 然后再乘上材质的颜色就是最后的颜色值了，也就是下面的完全公式
>
> **Diffuse = 直射光颜色 *材质颜色 * max(0,cos夹角(光和法线的夹角))**
>
> 
>
> 在半兰伯特光照模型公式中
>
> **Diffuse = 直射光颜色 \* 材质颜色 \* (dot(光源方向, 法线方向) \* 0.5 + 0.5)**

### 什么是万向锁

> 大前提，欧拉旋转三个轴具有层级关系：y-x-z。即x轴旋转时，z轴也会跟着旋转。同样地，y轴旋转时xz轴也会跟着旋转。
>
> 当x轴旋转时，导致z轴与y轴重合，