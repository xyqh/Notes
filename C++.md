# C++

## 类

### 什么是面向对象编程

> 面向对象（Object Oriented，OO）是一种计算机编程的思想和方法，它的核心是将程序中的行为主体定义为对象。
>
> 面向对象编程（Object Oriented Programming，OOP），是使用面向对象思想进程程序设计的一种方法，以对象作为基本的结构单位。

### inline函数与普通函数的区别

> 1. 编译器会在调用内联函数的地方将内联函数内容展开，这样既避免了函数调用的开销，又没有宏机制的缺陷。
> 2. 普通函数在被调用时，系统首先要到函数的入口地址去执行函数体，执行完成之后到函数调用的地方继续执行，函数始终只有一个复制。
> 3. 而内联函数不需要寻址，在编译时期就已经将内联函数展开了。
> 4. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句。如果内联函数函数体过于复杂，编译器将自动把内联函数当前普通函数来执行。

### inline函数和宏定义的区别

> 1. 宏定义是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换。
> 2. 内联函数则是在编译时期进行代码插入，编译器会在调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用开销，提升效率。
> 3. 宏定义是没有类型检查的，，无论对错都直接替换，而内联函数会进行安全检查。

### 如何实现模板类的声明与实现分离

> 常见的解决方案是将模板声明写入头文件中，然后在实现文件中实现该类（例如.tpp），并在头末尾包含该实现文件。
>
> 在分离文件的实现中，如下所示：
>
> ```
> //test.tpp
> template <typename T>
> void Foo<T>::doSomething(T param)
> {
>     //implementation
> }
> ```

### 模板函数和模板类的特例化

> 引入原因：编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这是就需要模板特例化。
>
> 定义：对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上。
>
> #### 模板函数特例化
>
> ```cpp
> template<typename T>
> int compare(const T &v1, const T &v2)
> {
>     if(v1 > v2) return -1;
>     if(v1 < v2) return 1;
>     return 0;
> }
>
> // 模板特例化
> template<>
> int compare(const char* const &v1, const char* const &v2)
> {
>     return strcmp(p1, p2);
> }
> ```
>
> 本质：特例化的本质是实例化一个模板，而不是重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如compare(3,5)则调用普通的模板，而compare("hi","ha")则调用特例化模板。
>
> 注意：模板函数不能偏特化，只能全特化。（即保留部分T，实例化部分T是不行的）
>
> #### 类模板特例化
>
> ##### 类模板的全特化
>
> ```cpp
> template <typename T, typename U>
> class A    // 主模板
> {
> public:
> 	A() { cout << "A<T, U>::A()" << endl; }
> 	void fun() { cout << "A<T, U>::fun()" << endl; }
> };
>
> template <>
> class A<int, int>    // 类模板的全特化
> {
> public:
> 	A() { cout << "A<int, int>::A()" << endl; }
> 	void fun() { cout << "A<int, int>::fun()" << endl; }
> };
> ```
>
> ##### 类模板的偏特化
>
> ```cpp
> template <typename T, typename U, typename W>
> class A    // 主模板
> {
> public:
> 	A() { cout << "A<T, U, W>::A()" << endl; }
> 	void fun() { cout << "A<T, U, W>::fun()" << endl; }
> };
>
> template <typename U>
> class A<int, U, double>    // 类模板根据模板参数数量进行偏特化
> {
> public:
> 	A() { cout << "A<int, U, double>::A()" << endl; }
> 	void fun() { cout << "A<int, U, double>::fun()" << endl; }
> };
> ```
>
> ##### 类模板成员函数特化
>
> ```cpp
> template <typename T, typename U>
> class A    // 主模板
> {
> public:
> 	A() { cout << "A<T, U>::A()" << endl; }
> 	void fun() { cout << "A<T, U>::fun()" << endl; }
> };
>
> template <>
> void A<int, double>::fun()    // 类模板成员函数的全特化
> {
> 	cout << "A<int, double>::fun()" << endl;
> }
> ```

### 类中的static

> 1. 初始化只有一次，但可以多次赋值，在主程序之前，编译器已经为其分配好了内存。
> 2. 在C++中，全局static变量和class的static成员变量在main函数之前初始化，main函数之后销毁
> 3. 函数内部的局部static变量在该函数第一次被调用时初始化，在main函数之后销毁
> 4. 特别说明1：关于类的static成员变量，不能在类内部初始化，即使添加了const也不行，成员函数（无论是否静态）也不行。同时，也不能在main里初始化，因此，只能在main之外初始化，即与全局static变量一致。
> 5. 特别说明2：static成员变量无法在全局区赋值修改，在全局区只能通过初始化进行定义，同样不支持重定义。但是可以在main函数中进行修改（前提是public）。
> 6. **特别说明3：成员变量可以同时加const和static，此时定义时必须添加const。同时，类外部初始化时可以无视private属性，即使用A::a（一般情况下，私有成员变量无法被访问）。**
> 7. 普通成员可以访问所有成员变量及成员函数（static和const），static/const对象只能访问static/const成员变量和成员函数。

### 类中的const

> 1. 常量必须在定义时初始化，之后无法修改
> 2. 常函数不能修改一般成员变量
> 3. 常对象只能调用常函数以及访问常对象
> 4. 加了mutable的成员变量，常函数中可以进行修改

### C++在构造函数和析构函数中的异常

> 可以但不建议。可能导致初始化不完全或者内存泄漏。

### 类中的默认成员函数有哪几种

> 1. 构造函数。无参的构造函数和全缺省的构造函数 **都称为默认的构造函数** ，并且默认构造函数**至多只能有一个。**
> 2. 析构函数
> 3. 拷贝构造函数
> 4. 赋值运算符重载
> 5. &取址运算符重载
> 6. const取址运算符重载





## 多态

### 多态的种类、定义以及实现

> #### 种类：
>
> 静态多态：主要指函数重载
>
> 动态多态：主要指**父类的指针或引用**调用、重写虚函数。如果**父类的指针或引用**指向父类，就调用父类的虚函数；如果**父类的指针或引用**指向某个子类，就调用那个子类的虚函数。
>
> #### 定义：
>
> 通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
>
> #### 实现：
>
> 1. 通过父类指针或引用调用虚函数
> 2. 通过父类声明虚函数，子类对虚函数进行重写

### 虚函数如何实现多态

> 需要引入虚函数表和虚表指针的概念：
>
> **虚函数表**：简称**虚表**。类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。
>
> **虚表指针**：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的是指向虚表的指针。
>
> **实现多态的过程**：
>
> 1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址
> 2. 编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚表指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
> 3. 所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
> 4. 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚拟函数地址添加在后面
>
> 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

### 虚函数表

> 1. 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
> 2. 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
> 3. 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中
>
> 根据以上特征，虚函数表与静态成员变量类似，最有可能在全局数据区，测试结果显示：
>
> 虚函数表在Linux/Unix中存放在可执行文件的**只读数据段**中(rodata)，这与微软的编译器将虚函数表存放在**常量段**存在一些差别

### 虚表指针什么时候产生

> 编译时产生，构造时初始化（把虚表地址赋给虚表指针）

### 虚函数表如何生成，跟类绑定还是跟对象绑定

> 虚函数表创建时机是在编译期间。编译期间编译器就为每个类确定好了对应的虚函数表里的内容。（跟类绑定）

### 虚函数和纯虚函数

> #### 虚函数：
>
> 1. 当在基类中把成员函数定义为虚函数后，在其派生类中定义的虚函数必须与基类中的虚函数同名，参数的类型、顺序、参数的个数必须一一对应，函数的返回的类型也相同。若函数名相同，但参数的个数不同或者参数的类型不同时，则属于函数的重载，而不是虚函数。若函数名不同，显然这是不同的成员函数。
> 2. 实现这种动态的多态性时，必须使用基类类型的指针变量，并使该指针指向不同的派生类对象，并通过调用指针所指向的虚函数才能实现动态的多态性。
> 3. 虚函数必须是类的一个成员函数，不能是友元函数，也不能是静态成员函数。
> 4. 在派生类中没有重新定义虚函数时，与一般的成员函数一样，当调用这种派生类对象的虚函数时，则调用其基类中的虚函数。
> 5. 可以把析构函数定义为虚函数，但是，不能将构造函数定义为虚函数。
> 6. 虚函数与一般的成员函数相比，调用时的执行函数要慢一些。为了实现多态性，在每一个派生类中均要保存相应虚函数的入口地址表，函数的调用机制也是间接实现的。因此，除了要编写一些通用的程序，并一定要使用虚函数才能完成其功能要求外，通常不必使用虚函数。
> 7. 一个函数如果被定义为虚函数，则不管经历多少次派生，仍将保持其虚特性，以实现“一个接口，多个形态”。(在多重继承中，每一层派生类是否加virtual不影响编译及结果；当在某一层被声明为final后，后续不能在重写，否则会编译报错。)
>
> #### 纯虚函数：
>
> 1. 在定义纯虚函数时，不能定义虚函数的实现部分。(《C++Primer》中文第五版p541，可以为纯虚函数提供定义，但函数体必须定义在类的外部。)
> 2. 把函数名赋值为0，本质上是将指向函数体的指针值赋值为0。与定义空函数不一样，空函数的函数体为空，即调用该函数时，不执行任何动作。没有在派生类重新定义这种虚函数之前，是不能调用这种纯虚函数的。
> 3. 把至少包含一个纯虚函数的类，称为抽象类。这种类只能作为派生类的基类，不能用来创建对象。
> 4. 派生类必须实现纯虚函数。(只要派生类不需要初始化，那么就可以不实现纯虚函数。)

### 重载、重写、隐藏的区别，子类重写了虚函数会对虚函数表有什么影响

> 重载：同一个类中，函数名相同，参数列表不同，返回值任意。
>
> 重写：派生类中，重写基类的虚函数，函数名相同，参数列表相同，返回值相同。
>
> #### 隐藏：派生类中的函数屏蔽了基类中的同名函数。
>
> 1. 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
> 2. 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。

### 多继承的实现，可能出现的问题

> 同名成员变量：两个基类中都有但派生类中没有时，编译不通过，需要添加类名。派生类中存在就用派生类的。
>
> 同名成员函数：两个基类中都有但派生类中没有时，编译不通过，需要添加类名。派生类中存在就用派生类的。
>
> 菱形继承

### 菱形继承

> B:A C:A D:B,C
>
> 会有两份A的数据，可以使用虚继承解决。

### 类对应的对象大小及内存布局

> 空类：1（在派生类计算基类大小时，若基类为空类，则为0）
>
> 普通类：非静态成员变量大小
>
> 有虚函数：加一个虚表指针大小
>
> 单继承类（无虚函数）：加一份基类的大小
>
> 单继承类（有虚函数）：虚表指针只有一份，加一份基类的大小
>
> 单虚继承（无论是否有虚函数）：要加个虚基类指针，指向虚基类表

### 虚表结构

> D为派生类，B为基类
>
> 无虚函数覆盖：基类虚函数->派生类虚函数（按照声明顺序），B::a() B::b() D::a1() D::b1()
>
> 有虚函数覆盖：基类虚函数->派生类虚函数（按照声明顺序），D::a() B::b() D::b1()
>
> 多重继承（无虚函数覆盖）：B1 D B2 B3，按照声明顺序
>
> 多重继承（有虚函数覆盖）：B1 D B2 B3，按照声明顺序。所有基类虚函数都覆盖，结合23点

### final和override

> final后子类不能重写，否则编译报错
>
> override标识重写，一般可省略

### 基类不使用虚析构函数，会发生什么

> 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。如果基类的析构函数不是虚函数，那么只有基类的内存会被释放，派生类的不会。

### 为什么C++编译器不把析构函数设置为虚函数

> 虚函数需要额外的内存，来存储虚函数表和虚表指针，对于不需要被继承的类来说，这样会浪费内存。

### 构造函数可以是虚函数吗，为什么

> 不可以。虚函数的执行依赖虚函数表，而虚表指针在调用构造函数时才初始化，那么编译器将无法知道应该调用哪一个虚构造函数，导致程序无法继续进行。





## 指针

### 指针和引用的区别

> | 指针                                                                                                                 | 引用                                         |
> | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
> | 是变量，存储着一个地址                                                                                               | 跟原变量本质上是同一个东西，是原变量的别名   |
> | 可以有多级指针                                                                                                       | 只有一级                                     |
> | 可以为空，定义和初始化分离                                                                                           | 不能为空，且定义的时候必须初始化             |
> | 初始化之后可以改变指向                                                                                               | 初始化之后不可再改变                         |
> | sizeof得到指针的大小                                                                                                 | sizeof得到原变量的大小                       |
> | 作为参数传递时，是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，函数体中可以改变指向不影响原指针 | 传递的是实参本身，函数体中的修改会影响原变量 |
>
> 一般地，可以把引用看作是："int& b = a;" =?= "int * const b = &a;"

### 指针指向的是逻辑地址还是物理地址

> 指向的是进程内的一个逻辑内存地址，然后由操作系统管理着从逻辑地址到物理地址的映射。

### new/delete和malloc/free的区别

> | new                                  | malloc              | delete                                   | free           |
> | ------------------------------------ | ------------------- | ---------------------------------------- | -------------- |
> | C++运算符                            | C/C++语言标准库函数 |                                          |                |
> | 自动计算需要分配的空间大小           | 手动计算            |                                          |                |
> | 类型安全                             | 非类型安全          |                                          |                |
> | 分配足够空间并调用相关对象的构造函数 | 仅分配空间          | 调用相关对象的析构函数并释放对象所用内存 | 仅释放内存     |
> | 不需要库文件支持                     | 需要库文件支持      | 不需要库文件支持                         | 需要库文件支持 |
> | new对malloc进行了封装                |                     |                                          |                |
> | 返回具体的类型指针                   | 返回void*           |                                          |                |

### delete和delete[]

> delete只会调用一次析构函数
>
> delete[]会调用数组中每个元素的析构函数

### 区别指针类型

> 数组和函数
>
> | 表达式        | 含义                                             |
> | ------------- | ------------------------------------------------ |
> | int *p[10]    | 指针数组，数组中有10个元素，每个元素都是一个指针 |
> | int (*p)[10]  | 数组指针，指向int类型的数组，大小为10            |
> | int *p(int)   | 函数声明，int *是返回值，int是参数列表           |
> | int (*p)(int) | 函数指针，指向形参为int返回值为int的函数         |
>
> const
>
> | 表达式                       | 含义                                               |
> | ---------------------------- | -------------------------------------------------- |
> | int * p                      | int指针                                            |
> | const int * p或int const * p | 指针常量，指针指向的内容不可以修改                 |
> | int * const p                | 常指针，指针的指向不可以修改                       |
> | const int * const p          | 指向常量的常指针，指针指向以及指向内容都不可以修改 |

### 数组名和指针（指向数组首元素的指针）的区别

> 1. 二者都可以通过增减偏移量来访问数组中的元素
> 2. 数组名可以理解为常指针，没有自增自减操作
> 3. 当数组名作为形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增自减操作

### 野指针和悬空指针

> 野指针：没有被初始化过的指针。（初始化或置空）
>
> 悬空指针：指针最初指向的内存已经被释放了的一种指针。（释放后置空）

### 深拷贝和浅拷贝

> 当对象中含有指针域时，C++的默认拷贝构造函数和=操作都是浅拷贝操作。
>
> 浅拷贝：只是拷贝指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一个地址，如果原来的指针指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。
>
> 深拷贝：不仅拷贝值，还新开辟一个地址用来存放新的值。

### NULL和nullptr的区别

> NULL来自C语言，一般有宏定义实现。在C语言中，NULL被定义为(void*)0，而在C++中，NULL则被定义为整数0.
>
> nullptr是C++11的新增关键字。
>
> ```
> void fun(char* p){}
> void fun(int p){}
> ```
>
> 当fun(NULL)时，会把NULL当成整数0来看，但是想调用参数是指针的函数就办不到了。
>
> 因此引入了nullptr，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整形，所以不会造成参数传递错误。

### 什么是无效引用

> 只查到了非常量引用无效，一般是指int &a = 1;这种需要加一个const int &a = 1;其他的情况就是函数返回临时变量，但是返回值类型是一个引用。





## 智能指针

### 原理

> 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄露。动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源。

### shared_ptr

> #### 实现原理：
>
> 采用引用计数的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数+1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动释放动态分配的资源。
>
> 1. 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
> 2. 每次创建新对象时，初始化指针并将引用计数置为1
> 3. 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相对应的引用计数
> 4. 对一个对象赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数减至0，则删除对象），并增加右操作数所指对象的引用计数
> 5. 调用析构函数时，减少引用计数（如果引用计数减至0，则删除基础对象）

### unique_ptr

> unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源（确保只有一个指针可以指向资源）。转移一个unique_ptr将会把所有权从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在stl标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你通过初始化2个unique_ptr裸指针之后，两个unique_ptr都reset到同一个普通指针，那么这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

### weak_ptr

> weak_ptr，弱引用指针。引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的声明周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，该内存都会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前应该使用lock()检查weak_ptr是否为空指针。

### auto_ptr

> 主要是为了解决“有异常抛出时发生内存泄漏”的问题。因为发生异常而无法正常释放内存。
>
> 被C++11抛弃的主要原因：
>
> 复制或者赋值会改变资源的所有权。
>
> auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。
>
> auto_ptr不支持拷贝和赋值操作，不能用在stl标准容器中。stl容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，不能在stl中使用。

### shared_ptr怎么实现多指针指向同一个地址

> 引用计数，调用拷贝/移动构造函数时会指向同一块地址，引用计数减为0时才释放资源。

### 不同的类实例的指针之间怎么同步引用计数

> 多个智能指针指向同一片空间实际上是1个计数器对象和多个shared_ptr对象，每个shared_ptr对象中存储的都是计数器的地址，操作引用计数时通过地址寻址操作同步。

### shared_ptr的构造、拷贝构造、析构函数

> 构造、拷贝构造引用计数加1，析构引用计数减1；
>
> =(赋值号)时，右侧计数加1，左侧计数减1

## STL

|          | vector                                                    | deque                                                                                                         | list           | map            | unordered_map                                                                          |
| -------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------- | -------------- | -------------------------------------------------------------------------------------- |
| 描述     | 数组                                                      | 双端数组                                                                                                      | 列表           |                |                                                                                        |
| 底层实现 | 3个变量，标识起始位置，当前存储结束位置以及总容量         | 一个映射区（指针数组）存储缓冲区地址，缓冲区地址真正存储数据                                                  | 双向链表       | 红黑树         | 哈希表(链地址但是vector)                                                               |
| 插入     | 头部慢，尾部快，中部慢，初始在头部插入                    | 头尾都快，中部慢，初始在中间插入                                                                              | o(1)           | o(logn)        | o(1)                                                                                   |
| 扩容     | 寻找一块内存足够的区域全部移动过去，一般是2倍当前容量扩容 | 寻找一块内存足够的区域全部移动过去，一般是2倍当前容量扩容。头部没空间时找尾部，反之亦然，直至都没空间才会扩容 | 非连续存储结构 | 非连续存储结构 | 当插入表里的元素个数超过了vector的容量，就会进行重建，即在质数表中找到下一个更大的质数 |
| 删除     | 同插入                                                    | 同插入                                                                                                        | o(1)           | o(logn)        | o(1)                                                                                   |
| 访问     | 支持随机访问                                              | 支持随机访问，但要经过一个映射区（稍慢）                                                                      | o(n)           | o(logn)        | o(1)                                                                                   |

### 哈希冲突如何解决

> 1. 开放定址法：遇到冲突时，去找一个新的空闲的地址
>    1. 线性探测法：往后+1取余直到找到空余位置。h(x)=(Hash(x)+i)mod (Hashtable.length);（i会逐渐递增加1）
>    2. 平方探测法（二次探测）：会前后寻找而不是单独方向的寻找。h(x)=(Hash(x) +i)mod (Hashtable.length);（i依次为+(i^2)和-(i^2)）
> 2. 再哈希法：重复用哈希直到不冲突
> 3. 链地址法：冲突的都放到一个链表里
> 4. 建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。

### 迭代器失效

> vector插入数据时，插入位置之后的迭代器通通失效，插入位置之前的迭代器可能失效。根本原因在于存储空间的变化。





## 结构体和内存对齐

### 结构体大小计算

> 默认四位对齐，指针大小也是4。修改内存对齐方式：#pragma pack(n)。
>
> 对齐大小 = （结构体内最大的数据类型大小，对齐位数）
>
> char int char：大小12；char char int：大小8；加虚函数大小加4（需要虚指针）。加static不影响大小因为不跟随对象（存在静态存储区）。

### 为什么要内存对齐

> 内存对齐指计算机系统要求基本类型数据在内存中存放的首地址的值是某个数的倍数（通常是4或8）。
>
> CPU访问内存时并不是逐字节访问，而是以字长为单位访问。比如32位的cpu，字长为4字节，那么CPU访问内存的单位也是4字节。这么设计的目的是减少CPU访问内存的次数，加大CPU访问内存的吞吐量。假如int类型的数据存在位置1，那么cpu取这个数据需要取2次（[0,3]以及[4,7])。





## 异常

### 异常的使用

> 使用形如try{throw()}catch(){}的做法
>
> ```c++
> int main(){
>  int x;
>  cin >> x;
>  try{
>      if(x < 5){
> 
>      }else if(x < 10){
>          throw(1);
>      }else if(x < 20){
>          throw("10<=x<20");
>      }else if(x < 30){
>          throw('a');
>      }
>      cout << x << endl;
>  }
>  catch(int _x){
>      cout << "catch error int " << _x << endl;
>  }
>  catch(const char* errmsg){
>      cout << "catch error const char* " << errmsg << endl;
>  }
> catch(const std::exception& e){
>     cout << e.what() << endl;
> }
>  catch(...){
>      cout << "unknown error" << endl;
>  }
>  return 0;
> }
> ```
>
> 1. 代码中抛出异常的话，throw所在域后面的内容是不会执行的
> 2. catch语句执行完之后还可以继续后面的内容
> 3. 捕获异常时可以用多个catch语句来捕获不同的异常
> 4. 如果抛出的异常没有任何catch可以匹配的话，那么编译器会终止程序并发出警告
> 5. 同一个作用域内不能存在相同类型的catch，但不同作用域内可以存在相同类型的catch，异常匹配时按照就近原则，一旦匹配之后不会再往调用链传递
> 6. 在构造函数或析构函数抛出异常可能导致初始化不完全或者内存泄漏
> 7. 使用catch(...)捕获任意异常，当...写在最前时，可能会提示”处理程序由默认处理程序屏蔽“，且编译失败
> 8. 抛出异常时，捕获到的异常对象是一个临时拷贝，但是编译器会做将亡值的优化





## 其他常见面试题

### C++四种类型转换

> #### static_cast：可以用于基本数据类型之间的转换，也可以将基类指针或引用转换为派生类指针或引用，但是转换时需要保证类型转换是安全的。静态转换不能用于去除对象的const、volatile属性。
>
> 1. 基本数据类型之间的转换
> 2. 枚举类型之间的转换
> 3. 指针类型转换成void*
> 4. 将一个变量转换成常量（加const）
> 5. 基类和派生类之间的转换（没有虚函数）
> 6. 没有关系的类之间的转换
>
> #### dynamic_cast：主要用于将基类指针或引用转换为派生类指针或引用，但是转换时需要判断类型转换是否安全，如果不安全则返回空指针。只有指向具有多态性质的类的基类指针或引用才能使用dynamic_cast。
>
> 1. 当使用dynamic_cast时，该类型要包含有虚函数，才能进行转换，否则编译错误。
> 2. 没有关系的类之间的转换也可以编译通过，但会返回空指针。
>
> ##### dynamic_cast的原理：
>
> - type_info是C++标准所定义的类型描述器，type_info中放置着每个类的类型信息。虚函数表的第一个slot存有type_info的地址。
> - 目标指针所指的对象的type_info会被编译器产生出来，源指针的对象的type_info在运行时通过虚表指针取得。然后比较这两个type_info是否吻合，吻合则返回转换后的指针，否则返回nullptr。
>
> #### reinterpret_cast：适用于指针转换为另一种指针，转化不用修改指针变量值数据存储格式，不改变指针变量的值，只需要在编译时重新解释指针的类型即可。也可以将指针，直接转化成整形值。
>
> 1. 相比dynamic_cast的返回空指针，这里我试了一下不是空指针。
> 2. 转换之后能正常操作成员变量，以及正常调用普通函数，但是不能正常调用虚函数（自己的虚函数，父类没定义过的）。
>
> #### const_cast：可以移除变量的const属性。
>
> ```
>     const int cb = 10;
>     // volatile const int cb = 10;
>     int *p = const_cast<int*>(&cb);
>     *p = 30;
>     cout << (void*)&cb << " " << cb << endl;
>     cout << p << " " << *p << endl;
> ```
>
> 输出是：
>
> 0x62ff00 10
> 0x62ff00 30
>
> 如果使用**volatile**对const int进行修改，那么结果就都是“0x62ff00 30”，另外需注意volatile修饰的变量取址后需要转成void*才能使用cout输出，否则输出1。

### 左值和右值

> #### 左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值。
>
> ```
> const int& a = 1;
> ```
>
> #### 右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用就可以更改右值。

### 左值引用和右值引用

> #### 左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用。
>
> #### 定义右值引用的格式如下：
>
> ```
> 类型 && 引用名 = 右值表达式;
> int &&var = 10;
> ```
>
> 右值引用的作用：右值引用可以进行读写操作，而常引用只能进行读操作。（这里提常饮用是由于此处所举的左值和右值的例子）可以充分利用右值（特别是临时对象）的构造来减少对象构造和析构操作以达到提高效率的目的。
>
> 需要提供带右值引用的拷贝构造函数和赋值运算符重载函数，在调用时一般入参是右值（简单理解为临时变量）。
>
> 左值引用有时也可以绑定到右值即常引用。

### 什么是引用折叠

> 首先理解万能引用，T&&的可能是左值引用，也可能是右值引用。
>
> 如果一个变量或者参数被声明为T&&，其中T是被推导的类型，那这个变量或者参数就是一个万能引用，一般是入参（T&&）或者类型推导（auto&&）。
>
> 当我们传入int &时，T&&变成了int & &&，这么写是非法的，但T&&又是合法的，于是就有了引用折叠：
>
> 1. 当T&&或者auto&&接收右值时，得到的是右值引用。
> 2. 其他情况都是左值引用。

### std::move()和std::forward()

> 1. forward做的是，在参数传递时由于引用折叠导致的原本入参的左/右值性。
> 2. move做的是，在参数传递时把参数变为右值引用进行传递。
>
> #### remove_reference
>
> ```
> template<typename _Tp>
> struct remove_reference
> { typedef _Tp   type; };
>
> // 特化版本
> template<typename _Tp>
> struct remove_reference<_Tp&>
> { typedef _Tp   type; };
>
> template<typename _Tp>
> struct remove_reference<_Tp&&>
> { typedef _Tp   type; };
> ```
>
> #### std::forward
>
> ```
> template<typename _Tp>
> constexpr _Tp&&
> forward(typename std::remove_reference<_Tp>::type& __t) noexcept
> { return static_cast<_Tp&&>(__t); }
>
> template<typename _Tp>
> constexpr _Tp&&
> forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
> {
>   static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
>         " substituting _Tp is an lvalue reference type");
>   return static_cast<_Tp&&>(__t);
> }
> ```
>
> #### std::move
>
> ```
> template<typename _Tp>  constexpr typename std::remove_reference<_Tp>::type&&  move(_Tp&& __t) noexcept  
> { 
>     return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); 
> }
> ```

### extern关键字

> 添加"extern"关键字，可以让编译器把"寻找定义"这件事情推迟到链接阶段，而不会在编译阶段报"没有定义"的错。
>
> 此外extern "C"的用法是在C++代码中正确地调用C语言的代码。

### 函数调用的过程

> ```c
> #include <stdio.h>
>
> int func(int param1 ,int param2,int param3)
> {
>         int var1 = param1;
>         int var2 = param2;
>         int var3 = param3;
>
>         printf("var1=%d,var2=%d,var3=%d",var1,var2,var3);
>         return var1;
> }
>
> int main(int argc, char* argv[])
> {
>         int result = func(1,2,3);
>
>         return 0;
> }
> ```
>
> **1.函数main执行，main各个参数从右向左逐步压入栈中，最后压入返回地址**
>
> **2.执行第15行，3个参数以从左向右的顺序压入堆栈，及从param3到param1**
>
> **3.然后是返回地址入栈：此时的栈内分布如下：**
>
> **4.第3行函数调用时，通过跳转指令进入函数后，函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP，此时栈顶和栈底指向同一位置，栈内分布如下：对应的汇编指令**：
>
> ```
> push ebp
> mov ebp esp
> ```
>
> | 高地址 | ...         |            |     |
> | ------ | ----------- | ---------- | --- |
> |        | param3      | 0x0012FF30 |     |
> |        | param2      | 0x0012FF2C |     |
> |        | param1      | 0x0012FF28 |     |
> |        | RET返回地址 | 0x0012FF24 |     |
> |        | EBP         | 0x0012FF20 | EBP |
> |        | var1        | 0x0012FF1C |     |
> |        | var2        | 0x0012FF18 |     |
> | 低地址 | var3        | 0x0012FF14 | ESP |
>
> **5.第5行开始执行， int var1 = param1; int var2 = param2; int var3 = param3;按申明顺序依次存储**。对应的汇编：
>
> 其中将[EBP+0x8]地址里的内容赋给EAX，即把param的值赋给EAX，然后把EAX的中的值放到[EBP-4]这个地址里，即把EAX值赋给var1，完成C代码 int var1 = param1，其他变量雷同。
>
> ```
> mov 0x8(%ebp),%eax
> mov %eax,-0x4(%ebp)
> ```
>
> **6.第9行，输出结果，第10行执行 对应的汇编代码：**
>
> ```
> mov  -0x4(%ebp),%eax
> ```
>
> **7.调用执行函数完毕，局部变量var3，var2，var1一次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，param1，param2，param3依次出栈，函数调用执行完毕。图略**
>
> https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html

### 堆和栈的区别

> |              | 堆                                                           | 栈                                                           |
> | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 管理方式     | 堆中资源由程序员控制                                         | 栈资源由编译器自动管理，无需手工控制                         |
> | 内存管理机制 | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该节点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于申请空间，系统为程序提供内存，否则报异常提示栈溢出 |
> | 空间大小     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然是不连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（在编译时确定，VC中可设置） |
> | 碎片问题     | 频繁的new/delete会造成大量碎片，使程序效率降低               | 不会产生内存碎片                                             |
> | 生长方向     | 堆向上，由低地址到高地址                                     | 栈向下，由高地址到低地址                                     |
> | 声明周期     | 数据只要不释放就一直存在                                     | 数据仅存在于函数运行过程中                                   |
> | 分配方式     | 堆都是动态分配                                               | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配资源由编译器进行释放，无需程序员实现 |
> | 分配效率     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多      | 栈是其系统提供的数据结构，计算机在底层堆栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令 |

### memcpy实现

> ```c++
> // 不考虑地址重叠问题
> void* memcpy(void* dst, const void* src, size_t size)
> {
> 	if(src == nullptr || dest == nullptr || size <= 0){
> 		return nullptr;
> 	}
>
> 	void *ret = dst;
> 	while(size--){
> 		*(char *)dst = *(char *)src;
>         dst = (char *)dst + 1;
>         src = (char *)src + 1;
> 	}
>     return ret;
> }
> ```
> ```c++
> // 考虑地址重叠问题
> void memcpy(void* dst, const void* src, size_t size)
> {
> 	if(src == nullptr || dest == nullptr || size <= 0){
> 		return nullptr;
> 	}
>   
>     void *ret = dst;
>     if(dst <= src || (char *)dst >= (char *)src + size){
>         while(size--){
>             *(char *)dst = *(char *)src;
>             (char *)dst = (char *)dst + 1;
>             (char *)src = (char *)src + 1;
>         }
>     }else{
>         (char *)dst = (char *)dst + size - 1;
>         (char *)src = (char *)src + size - 1;
>         while(size--){
>             *(char *)dst = *(char *)src;
>             (char *)dst = (char *)dst - 1;
>             (char *)src = (char *)src - 1;          
>         }
>     }
>     return ret;
> }
> ```
