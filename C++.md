# C++面试题

## 多态

### 多态的种类、定义以及实现

> #### 种类：
>
> 静态多态：主要指函数重载
>
> 动态多态：主要指**父类的指针或引用**调用、重写虚函数。如果**父类的指针或引用**指向父类，就调用父类的虚函数；如果**父类的指针或引用**指向某个子类，就调用那个子类的虚函数。
>
> #### 定义：
>
> 通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
>
> #### 实现：
>
> 1. 通过父类指针或引用调用虚函数
> 2. 通过父类声明虚函数，子类对虚函数进行重写

### 虚函数如何实现多态

> 需要引入虚函数表和虚表指针的概念：
>
> **虚函数表**：简称**虚表**。类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。
>
> **虚表指针**：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的是指向虚表的指针。
>
> **实现多态的过程**：
>
> 1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址
> 2. 编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚表指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
> 3. 所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
> 4. 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚拟函数地址添加在后面
>
> 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

### 虚函数表

> 1. 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
> 2. 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
> 3. 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中
>
> 根据以上特征，虚函数表与静态成员变量类似，最有可能在全局数据区，测试结果显示：
>
> 虚函数表在Linux/Unix中存放在可执行文件的**只读数据段**中(rodata)，这与微软的编译器将虚函数表存放在**常量段**存在一些差别

### 虚表指针什么时候产生

> 编译时产生，构造时初始化（把虚表地址赋给虚表指针）

### 虚函数表如何生成，跟类绑定还是跟对象绑定

> 虚函数表创建时机是在编译期间。编译期间编译器就为每个类确定好了对应的虚函数表里的内容。（跟类绑定）

### 虚函数和纯虚函数

> #### 虚函数：
>
> 1. 当在基类中把成员函数定义为虚函数后，在其派生类中定义的虚函数必须与基类中的虚函数同名，参数的类型、顺序、参数的个数必须一一对应，函数的返回的类型也相同。若函数名相同，但参数的个数不同或者参数的类型不同时，则属于函数的重载，而不是虚函数。若函数名不同，显然这是不同的成员函数。
> 2. 实现这种动态的多态性时，必须使用基类类型的指针变量，并使该指针指向不同的派生类对象，并通过调用指针所指向的虚函数才能实现动态的多态性。
> 3. 虚函数必须是类的一个成员函数，不能是友元函数，也不能是静态成员函数。
> 4. 在派生类中没有重新定义虚函数时，与一般的成员函数一样，当调用这种派生类对象的虚函数时，则调用其基类中的虚函数。
> 5. 可以把析构函数定义为虚函数，但是，不能将构造函数定义为虚函数。
> 6. 虚函数与一般的成员函数相比，调用时的执行函数要慢一些。为了实现多态性，在每一个派生类中均要保存相应虚函数的入口地址表，函数的调用机制也是间接实现的。因此，除了要编写一些通用的程序，并一定要使用虚函数才能完成其功能要求外，通常不必使用虚函数。
> 7. 一个函数如果被定义为虚函数，则不管经历多少次派生，仍将保持其虚特性，以实现“一个接口，多个形态”。(在多重继承中，每一层派生类是否加virtual不影响编译及结果；当在某一层被声明为final后，后续不能在重写，否则会编译报错。)
>
> #### 纯虚函数：
>
> 1. 在定义纯虚函数时，不能定义虚函数的实现部分。(《C++Primer》中文第五版p541，可以为纯虚函数提供定义，但函数体必须定义在类的外部。)
> 2. 把函数名赋值为0，本质上是将指向函数体的指针值赋值为0。与定义空函数不一样，空函数的函数体为空，即调用该函数时，不执行任何动作。没有在派生类重新定义这种虚函数之前，是不能调用这种纯虚函数的。
> 3. 把至少包含一个纯虚函数的类，称为抽象类。这种类只能作为派生类的基类，不能用来创建对象。
> 4. 派生类必须实现纯虚函数。(只要派生类不需要初始化，那么就可以不实现纯虚函数。)

### 重载、重写、隐藏的区别，子类重写了虚函数会对虚函数表有什么影响

> 重载：同一个类中，函数名相同，参数列表不同，返回值任意。
>
> 重写：派生类中，重写基类的虚函数，函数名相同，参数列表相同，返回值相同。
>
> #### 隐藏：派生类中的函数屏蔽了基类中的同名函数。
>
> 1. 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
> 2. 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。

### 多继承的实现，可能出现的问题

> 同名成员变量：两个基类中都有但派生类中没有时，编译不通过，需要添加类名。派生类中存在就用派生类的。
>
> 同名成员函数：两个基类中都有但派生类中没有时，编译不通过，需要添加类名。派生类中存在就用派生类的。
>
> 菱形继承

### 菱形继承

> B:A C:A D:B,C
>
> 会有两份A的数据，可以使用虚继承解决。

### 类对应的对象大小及内存布局

> 空类：1
>
> 普通类：非静态成员变量大小
>
> 有虚函数：加一个虚表指针大小
>
> 单继承类（无虚函数）：加一份基类的大小
>
> 单继承类（有虚函数）：虚表指针只有一份，加一份基类的大小
>
> 单虚继承：要加个虚基类指针

### 虚表结构

> D为派生类，B为基类
>
> 无虚函数覆盖：基类虚函数->派生类虚函数（按照声明顺序），B::a() B::b() D::a1() D::b1()
>
> 有虚函数覆盖：基类虚函数->派生类虚函数（按照声明顺序），D::a() B::b() D::b1()
>
> 多重继承（无虚函数覆盖）：B1 D B2 B3，按照声明顺序
>
> 多重继承（有虚函数覆盖）：B1 D B2 B3，按照声明顺序。所有基类虚函数都覆盖，结合23点

### final和override

> final后子类不能重写，否则编译报错
>
> override标识重写，一般可省略

### 基类不使用虚析构函数，会发生什么

> 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。如果基类的析构函数不是虚函数，那么只有基类的内存会被释放，派生类的不会。

### 构造函数可以是虚函数吗，为什么

> 不可以。虚函数的执行依赖虚函数表，而虚表指针在调用构造函数时才初始化，那么编译器将无法知道应该调用哪一个虚构造函数，导致程序无法继续进行。

### C++在构造函数和析构函数中的异常

> 可以但不建议。



## 指针

### 指针和引用的区别

> | 指针                                                                                                                 | 引用                                         |
> | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
> | 是变量，存储着一个地址                                                                                               | 跟原变量本质上是同一个东西，是原变量的别名   |
> | 可以有多级指针                                                                                                       | 只有一级                                     |
> | 可以为空，定义和初始化分离                                                                                           | 不能为空，且定义的时候必须初始化             |
> | 初始化之后可以改变指向                                                                                               | 初始化之后不可再改变                         |
> | sizeof得到指针的大小                                                                                                 | sizeof得到原变量的大小                       |
> | 作为参数传递时，是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，函数体中可以改变指向不影响原指针 | 传递的是实参本身，函数体中的修改会影响原变量 |
>
> 一般地，可以把引用看作是："int& b = a;" =?= "int * const b = &a;"

### new/delete和malloc/free的区别

> | new                                  | malloc              | delete                                   | free           |
> | ------------------------------------ | ------------------- | ---------------------------------------- | -------------- |
> | C++运算符                            | C/C++语言标准库函数 |                                          |                |
> | 自动计算需要分配的空间大小           | 手动计算            |                                          |                |
> | 类型安全                             | 非类型安全          |                                          |                |
> | 分配足够空间并调用相关对象的构造函数 | 仅分配空间          | 调用相关对象的析构函数并释放对象所用内存 | 仅释放内存     |
> | 不需要库文件支持                     | 需要库文件支持      | 不需要库文件支持                         | 需要库文件支持 |
> | new对malloc进行了封装                |                     |                                          |                |
> | 返回具体的类型指针                   | 返回void*           |                                          |                |

### delete和delete[]

> delete只会调用一次析构函数
>
> delete[]会调用数组中每个元素的析构函数

### 区别指针类型

> 数组和函数
>
> | 表达式        | 含义                                             |
> | ------------- | ------------------------------------------------ |
> | int *p[10]    | 指针数组，数组中有10个元素，每个元素都是一个指针 |
> | int (*p)[10]  | 数组指针，指向int类型的数组，大小为10            |
> | int *p(int)   | 函数声明，int *是返回值，int是参数列表           |
> | int (*p)(int) | 函数指针，指向形参为int返回值为int的函数         |
>
> const
>
> | 表达式                       | 含义                                               |
> | ---------------------------- | -------------------------------------------------- |
> | int * p                      | int指针                                            |
> | const int * p或int const * p | 指针常量，指针指向的内容不可以修改                 |
> | int * const p                | 常指针，指针的指向不可以修改                       |
> | const int * const p          | 指向常量的常指针，指针指向以及指向内容都不可以修改 |

### 数组名和指针（指向数组首元素的指针）的区别

> 1. 二者都可以通过增减偏移量来访问数组中的元素
> 2. 数组名可以理解为常指针，没有自增自减操作
> 3. 当数组名作为形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增自减操作

### 野指针和悬空指针

> 野指针：没有被初始化过的指针。（初始化或置空）
>
> 悬空指针：指针最初指向的内存已经被释放了的一种指针。（释放后置空）

### 深拷贝和浅拷贝

> 浅拷贝：只是拷贝指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一个地址，如果原来的指针指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。
>
> 深拷贝：不仅拷贝值，还新开辟一个地址用来存放新的值。

### NULL和nullptr的区别

> NULL来自C语言，一般有宏定义实现。在C语言中，NULL被定义为(void*)0，而在C++中，NULL则被定义为整数0.
>
> nullptr是C++11的新增关键字。
>
> ```
> void fun(char* p){}
> void fun(int p){}
> ```
>
> 当fun(NULL)时，会把NULL当成整数0来看，但是想调用参数是指针的函数就办不到了。
>
> 因此引入了nullptr，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整形，所以不会造成参数传递错误。



## 智能指针

### 原理

> 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄露。动态分配的资源，交给一个类对象去管理，当类对象声明皱起结束时，自动调用析构函数释放资源。

### shared_ptr

> #### 实现原理：
>
> 采用引用计数的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数+1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动释放动态分配的资源。
>
> 1. 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
> 2. 每次创建新对象时，初始化指针并将引用计数置为1
> 3. 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相对应的引用计数
> 4. 对一个对象赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数减至0，则删除对象），并增加右操作数所指对象的引用计数
> 5. 调用析构函数时，减少引用计数（如果引用计数减至0，则删除基础对象）

### unique_ptr

> unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源（确保只有一个指针可以指向资源）。转移一个unique_ptr将会把所有权从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在stl标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你通过初始化2个unique_ptr裸指针之后，两个unique_ptr都reset到同一个普通指针，那么这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

### weak_ptr

> weak_ptr，弱引用指针。引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的声明周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，该内存都会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前应该使用lock()检查weak_ptr是否为空指针。

### auto_ptr

> 主要是为了解决“有异常抛出时发生内存泄漏”的问题。因为发生异常而无法正常释放内存。
>
> 被C++11抛弃的主要原因：
>
> 复制或者赋值会改变资源的所有权。
>
> auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。
>
> auto_ptr不支持拷贝和赋值操作，不能用在stl标准容器中。stl容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，不能在stl中使用。

### shared_ptr怎么实现多指针指向同一个地址

> 引用计数，调用拷贝/移动构造函数时会指向同一块地址，引用计数减为0时才释放资源。

### 不同的类实例的指针之间怎么同步引用计数

> 多个智能指针指向同一片空间实际上是1个计数器对象和多个shared_ptr对象，每个shared_ptr对象中存储的都是计数器的地址，操作引用计数时通过地址寻址操作同步。

### shared_ptr的构造、拷贝构造、析构函数

> 构造、拷贝构造引用计数加1，析构引用计数减1；
>
> =(赋值号)时，右侧计数加1，左侧计数减1
