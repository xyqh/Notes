# C++面试题

## 多态

### 多态的种类、定义以及实现

> #### 种类：
>
> 静态多态：主要指函数重载
>
> 动态多态：主要指**父类的指针或引用**调用、重写虚函数。如果**父类的指针或引用**指向父类，就调用父类的虚函数；如果**父类的指针或引用**指向某个子类，就调用那个子类的虚函数。
>
> #### 定义：
>
> 通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
>
> #### 实现：
>
> 1. 通过父类指针或引用调用虚函数
> 2. 通过父类声明虚函数，子类对虚函数进行重写

### 虚函数如何实现多态

> 需要引入虚函数表和虚表指针的概念：
>
> **虚函数表**：简称**虚表**。类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。
>
> **虚表指针**：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的是指向虚表的指针。
>
> **实现多态的过程**：
>
> 1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址
> 2. 编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚表指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数
> 3. 所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表
> 4. 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚拟函数地址添加在后面
>
> 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

### 虚函数表

> 1. 虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
>
> 2. 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
>
> 3. 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中
>
> 根据以上特征，虚函数表与静态成员变量类似，最有可能在全局数据区，测试结果显示：
>
> 虚函数表在Linux/Unix中存放在可执行文件的**只读数据段**中(rodata)，这与微软的编译器将虚函数表存放在**常量段**存在一些差别

### 虚表指针什么时候产生

> 编译时产生，构造时初始化（把虚表地址赋给虚表指针）

### 虚函数表如何生成，跟类绑定还是跟对象绑定

> 虚函数表创建时机是在编译期间。编译期间编译器就为每个类确定好了对应的虚函数表里的内容。（跟类绑定）

### 虚函数和纯虚函数

> #### 虚函数：
>
> 1. 当在基类中把成员函数定义为虚函数后，在其派生类中定义的虚函数必须与基类中的虚函数同名，参数的类型、顺序、参数的个数必须一一对应，函数的返回的类型也相同。若函数名相同，但参数的个数不同或者参数的类型不同时，则属于函数的重载，而不是虚函数。若函数名不同，显然这是不同的成员函数。
> 2. 实现这种动态的多态性时，必须使用基类类型的指针变量，并使该指针指向不同的派生类对象，并通过调用指针所指向的虚函数才能实现动态的多态性。
> 3. 虚函数必须是类的一个成员函数，不能是友元函数，也不能是静态成员函数。
> 4. 在派生类中没有重新定义虚函数时，与一般的成员函数一样，当调用这种派生类对象的虚函数时，则调用其基类中的虚函数。
> 5. 可以把析构函数定义为虚函数，但是，不能将构造函数定义为虚函数。
> 6. 虚函数与一般的成员函数相比，调用时的执行函数要慢一些。为了实现多态性，在每一个派生类中均要保存相应虚函数的入口地址表，函数的调用机制也是间接实现的。因此，除了要编写一些通用的程序，并一定要使用虚函数才能完成其功能要求外，通常不必使用虚函数。
> 7. 一个函数如果被定义为虚函数，则不管经历多少次派生，仍将保持其虚特性，以实现“一个接口，多个形态”。(在多重继承中，每一层派生类是否加virtual不影响编译及结果；当在某一层被声明为final后，后续不能在重写，否则会编译报错。)
>
> #### 纯虚函数：
>
> 1. 在定义纯虚函数时，不能定义虚函数的实现部分。(《C++Primer》中文第五版p541，可以为纯虚函数提供定义，但函数体必须定义在类的外部。)
> 2. 把函数名赋值为0，本质上是将指向函数体的指针值赋值为0。与定义空函数不一样，空函数的函数体为空，即调用该函数时，不执行任何动作。没有在派生类重新定义这种虚函数之前，是不能调用这种纯虚函数的。
> 3. 把至少包含一个纯虚函数的类，称为抽象类。这种类只能作为派生类的基类，不能用来创建对象。
> 4. 派生类必须实现纯虚函数。(只要派生类不需要初始化，那么就可以不实现纯虚函数。)

### 重载、重写、隐藏的区别，子类重写了虚函数会对虚函数表有什么影响

> 重载：同一个类中，函数名相同，参数列表不同，返回值任意。
>
> 重写：派生类中，重写基类的虚函数，函数名相同，参数列表相同，返回值相同。
>
> #### 隐藏：派生类中的函数屏蔽了基类中的同名函数。
>
> 1. 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。
> 2. 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。

### 多继承的实现，可能出现的问题

> 同名成员变量：两个基类中都有但派生类中没有时，编译不通过，需要添加类名。派生类中存在就用派生类的。
>
> 同名成员函数：两个基类中都有但派生类中没有时，编译不通过，需要添加类名。派生类中存在就用派生类的。
>
> 菱形继承

### 菱形继承

> B:A C:A D:B,C
>
> 会有两份A的数据，可以使用菱形继承解决。

### 类对应的对象大小及内存布局

> 空类：1
>
> 普通类：非静态成员变量大小
>
> 有虚函数：加一个虚表指针大小
>
> 单继承类（无虚函数）：加一份基类的大小
>
> 单继承类（有虚函数）：虚表指针只有一份，加一份基类的大小
>
> 单虚继承：要加个虚基类指针

### 虚表结构

> D为派生类，B为基类
>
> 无虚函数覆盖：基类虚函数->派生类虚函数（按照声明顺序），B::a() B::b() D::a1() D::b1()
>
> 有虚函数覆盖：基类虚函数->派生类虚函数（按照声明顺序），D::a() B::b() D::b1()
>
> 多重继承（无虚函数覆盖）：B1 D B2 B3，按照声明顺序
>
> 多重继承（有虚函数覆盖）：B1 D B2 B3，按照声明顺序。所有基类虚函数都覆盖，结合23点

### final和override

> final后子类不能重写，否则编译报错
>
> override标识重写，一般可省略

### 基类不使用虚析构函数，会发生什么

> 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。如果基类的析构函数不是虚函数，那么只有基类的内存会被释放，派生类的不会。

### 构造函数可以是虚函数吗，为什么

> 不可以。虚函数的执行依赖虚函数表，而虚表指针在调用构造函数时才初始化，那么编译器将无法知道应该调用哪一个虚构造函数，导致程序无法继续进行。

### C++在构造函数和析构函数中的异常

> 可以但不建议。
