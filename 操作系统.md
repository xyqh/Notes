# 操作系统

## 基础相关

### 文件描述符

> Linux系统总，把一切都看作是文件，当进程打开现有文件或者创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。

### 内核态和用户态

> 为了限制不同程序的访问能力，防止一些程序访问其他程序的内部数据，CPU划分了内核态和用户态两个权限等级。
>
> - 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换
> - 用户态只能受限地访问内存，且不允许访问外围设备，占有占用CPU的能力，CPU资源可以被其他成或许获取
>
> 所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。

### 如何从用户态切换到内核态

> 1. 系统调用，比如读取命令行输入，本质上还是通过中断实现
> 2. 异常，用户程序发生异常，比如缺页异常
> 3. 外中断，外围设备的中断，外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理相应的中断处理程序

### 临界资源、临界代码、临界区

> 1. 多个进程或线程有可能同时访问的资源（变量、链表、文件等）称为共享资源，也叫临界资源
> 2. 访问这些资源的代码称为临界代码，这些代码区域称为临界区
> 3. 程序进入临界区之前必须要对资源进行申请，这个动作称为P操作
> 4. 程序离开临界区之后必须要释放相应的资源，这个动作被称为V操作





## 进程和线程

### 进程与线程和协程的区别和联系

> |          | 进程                                                         | 线程                                                 | 协程                                                         |
> | -------- | ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
> | 定义     | 资源分配和调度的基本单位                                     | 程序执行的基本单位                                   | 用户态的轻量级线程，线程内部调度的基本单位                   |
> | 切换情况 | 进程CPU环境（栈、寄存器、页表、文件句柄等）的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容           | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复         |
> | 切换者   | 操作系统                                                     | 操作系统                                             | 用户                                                         |
> | 切换过程 | 用户态->内核态->用户态                                       | 用户态->内核态->用户态                               | 用户态（没有进入内核态）                                     |
> | 调用栈   | 内核栈                                                       | 内核栈                                               | 用户栈                                                       |
> | 拥有资源 | CPU资源、内存资源、文件资源和句柄等                          | 程序计数器、寄存器、栈和状态字                       | 拥有自己的寄存器上下文和栈                                   |
> | 并发性   | 不同进程之间切换实现并发                                     | 一个进程内部的多个线程并发执行                       | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
> | 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需要保存和设置少量寄存器内容，因此开销很小   | 直接操作栈则基本没有内核切换的开销，可以不加锁地访问全局变量，所以上下文的切换非常快 |
> | 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段（如全局变量）来进行通信 | 共享内存、消息队列                                           |
>
> 1. 进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序。
> 2. 线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。
> 3. 协程是用户态的轻量级线程，线程内部调度的基本单位。

### 相比进程，线程的优势

> 1. 线程启动速度快，轻量级
> 2. 线程的系统开销小
> 3. 线程使用有一定难度，需要处理数据一致性问题
> 4. 同一线程共享的有堆、全局变量、静态变量、指针、引用、文件等，而独自占有栈

### 一个进程可以创建多少线程

> 理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。
>
> 因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的简历就会成功。如果需要创建超过2K以上的线程，减小你的线程栈大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。

### 同一进程中的线程可以共享哪些数据

> - 进程代码段
> - 进程的公有数据（全局变量、静态变量...）
> - 进程打开的文件描述符
> - 进程的当前目录
> - 信号处理器/信号处理函数：对收到的信号的处理方式
> - 进程ID与进程组ID

### 线程独占哪些资源

> - 线程ID
> - 一组寄存器的值
> - 线程自身的栈（堆是共享的）
> - 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改
> - 信号掩码/信号屏蔽字：表示是否屏蔽/阻塞相应的信号（SIGKILL，SIGSTOP除外）

### 线程同步有哪些方式

> 为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。
>
> - **互斥量Mutex**：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权现。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源。
> - **信号量Semaphore**：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了**最大资源计数**和**当前可用资源计数**，每增加一个线程对共享资源的访问，当前可用资源计数减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过ReleaseSemephore函数将当前可用资源数加1.如果信号量的取址只能为0或1，那就退化成了互斥量。
> - **事件Event**：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为**手动重置事件**和**自动重置事件**。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。
> - **临界区Critical Section**：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其他试图访问该资源的线程将被挂起，直到临界区对象被释放。

### 互斥量和临界区的区别

> 互斥量是可以命名的，可以用于不同进程之间的同步。而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。

### 进程间通信（IPC）

> | 方式     | 传输的数据量       | 使用场景       | 关键词                                                       |
> | -------- | ------------------ | -------------- | ------------------------------------------------------------ |
> | 信号     | 少量               | 任何           | 硬件来源、软件来源、信号队列                                 |
> | 管道     | 大量               | 亲缘进程间     | 单向流动、内核缓冲区、循环队列、没有格式的字节流、操作系统负责同步 |
> | 命名管道 | 大量               | 任何           | 磁盘文件、访问权限、无数据块、内核缓冲区、操作系统负责同步   |
> | 信号量   | N                  | 任何           | 互斥同步、原子性、P减V增                                     |
> | 共享内存 | 大量               | 多个进程       | 内存映射、简单快速、操作系统不保证同步                       |
> | 消息队列 | 比信号多，但有限制 | 任何           | 有格式、按消息类型过滤、操作系统负责同步                     |
> | 套接字   | 大量               | 不同主机的进程 | 读缓存区、写缓存区、操作系统负责同步                         |
>
> #### 信号（Signal）
>
> > - 信号是Linus系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态
> > - 如果该进程当前并未处于执行状态，则该状态就由内核保存起来，直到该进程回复执行并传递给它为止
> > - 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，知道其阻塞被取消时才被传递给该进程
> >
> > ##### 信号来源
> >
> > 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号主要有两个来源：
> >
> > - 硬件来源：用户案件输入**Ctrl+C**退出、硬件异常如无效的存储访问等
> > - 软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号
> >
> > ##### 信号声明周期和处理流程
> >
> > 1. 信号被某个进程产生，并设置此信号的传递对象（一般为对应进程的pid），然后传递给操作系统。
> > 2. 操作系统根据此接收进程的设置（是否阻塞此信号）而选择性地发送给接收者，如果该接收者阻塞该信号（且该信号是可以被阻塞的），操作系统将暂时保留该信号而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经瑞出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。
> > 3. 目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后再恢复到中断的位置。当然，对于抢占式内核，在中段返回时还将引发新的调度。
>
> #### 管道（匿名管道PIPE）
>
> > - 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
> > - 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）。
> > - 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。
> > - 数据的读出和写入：一个进程向通道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
> >
> > ##### 管道的实质：
> >
> > - 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序地将数据写入缓冲区，另一端的进程则顺序地读出数据。
> > - 该缓冲区可以看作是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
> > - 当缓冲区读空或者写满时，有一定的规则控制读进程和写进程进入等待队列，当空的缓冲区有数据写入或者满的缓冲区有数据读出时，就会唤醒等待队列中的进程继续读写。
> > - 写进程或者读进程需要等另一方释放锁后才能操作管道，同一时间只能有一个进程访问
> > - 管道不再被任何进程使用时，自动消失
> >
> > ##### 管道的局限：
> >
> > - 只支持单向数据流
> > - 只能用于具有亲缘关系的进程
> > - 没有名字
> > - 缓冲区的大小是有限的，管道只存在于内存中，在管道创建时，为缓冲区分配一个页面大小
> > - 数据是无格式的字节流，需要发送方和接收方事先约定好数据的格式，例如多少个字节是一个消息或命令
> > - 匿名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出，如果管道发现另一端断开，将自动退出
>
> #### 命名管道（FIFO）
>
> > 匿名管道只能用于亲缘关系之间的进程通信，为了克服这一缺点，提出了命名管道。
> >
> > 不同于匿名管道的是，命名管道提供了一个路径名与之关联，以命名管道的文件形式存在于文件系统中，这样，即使与命名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过命名管道相互通信。命名管道严格遵循先进先出（FIFO），对读操作总是从开始处返回数据，写操作总是把数据添加到末尾，不支持如ISeek()等文件定位操作。命名管道的名字存在于文件系统中，内容存放在内存中。
> >
> > 命名管道在打开时需要确认对方的存在，否则将阻塞。此外可以以读写（O_RDWR）模式打开命名管道，即当前进程读当前进程写，不会阻塞。
>
> #### 消息队列
>
> > - 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符标识
> > - 与管道不同的是，消息队列只有在内核重启（即操作系统重启）或者显示删除一个消息队列时才会被真正删除
> > - 进程在向消息队列写入数据时，不需要有进程该消息队列上等待信息的到来
> >
> > 消息队列特点：
> >
> > - 是消息的链表，具有特定的格式，存在于内存中由消息队列标识符标识
> > - 允许一个或多个进程对消息队列进行读写
> > - 遵循先进先出
> > - 可以实现消息类型的随即查询，不一定要以先进先出的次序读取，也可以按照消息类型进行读取
> > - 克服了信号承载消息量少，管道只能承载无格式化字节流以及缓冲区大小受限等缺点
> > - 主要分为两种：POSIX消息队列和System V消息队列，其中V消息队列只有当内核重启或者显示删除时才会被真正删除
>
> #### 共享内存
>
> > - 使得多个进程可以直接读写同一块的内存区域，是最快的可用IPC形式。是针对其他进程通信机制允许效率较低设计的
> > - 为了在多个进程之间同步信息，内核专门留出了一块内存区，可以由需要访问的进程映射到自己的私有地址空间，而不需要进行数据拷贝直接进行读写，从而大大提高效率
> > - 由于多个进程共享一块内存，需要依靠某种同步机制（如信号量），来达到进程间的同步与互斥
>
> #### 信号量（semaphore）
>
> > 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间的同步。一般表示资源的数量。一般是一个数组。
> >
> > 1. **创建一个信号量**：这要求调用者指定初始值，对于二值信号量（在Linux中，又称互斥锁Mutex）来说，它通常是1，也可以是0.
> > 2. **等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞，否则减1，也称为**P**操作。
> > 3. **挂出一个信号量**：该操作将信号量的值加1，也称为**V**操作。
> >
> > Linux中，信号量的三种类型：
> >
> > 1. Posix（可移植性操作系统接口）有名信号量，使用Posix IPC名字标识
> > 2. Posix基于内存的信号量，存放在共享内存区中
> > 3. System V信号量，在内核中维护
>
> #### 套接字（Socket）
>
> > 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接的计算机上的进程进行通信。
> >
> > 套接字是支持TCP/IP的网络通信的基本单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的双方的一种约定，用套接字中的相关函数来完成通信过程。
> >
> > ###### 套接字特性：域、端口号、协议类型
> >
> > ###### 1. 域：指套接字通信中使用的网络介质，最常见的有两种
> >
> > > 1. AF_INET，指Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。
> > > 2. AF_UNIX，指UNIX文件系统。它就是文件输入/输出，而它的地址就是文件名。
> >
> > ###### 2. 套接字的端口号
> >
> > > 每一个基于TCP/IP网络通讯的程序（进程）都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序，低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。
> >
> > ###### 3. 套接字协议类型
> >
> > > 1. 流套接字，TCP协议
> > > 2. 数据包套接字，UDP协议
> > > 3. 原始套接字，原始套接字允许对较低层次的协议直接访问，比如IP、ICMP协议，它常用于校验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操作网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能处理的IP包，也可以用来发送一些自定包头或者自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。
> > >
> > > 原始套接字可以读写内核没有处理的IP数据包。如果要访问其他协议发送数据必须使用原始套接字。
> >
> > ##### 套接字通信的建立
> >
> > > 一个socket是可以建立多个TCP连接的。
> > >
> > > **服务端：**
> > >
> > > 1. 服务端应用程序用系统调用socket来创建一个套接字，它是系统分配给服务器进程的类似文件描述符的资源，不能与其他的进程共享。
> > > 2. 进程会给套接字起名字，使用系统调用bind来给套接字命名，然后服务器进程就开始等待客户端连接到这个套接字
> > > 3. 系统调用listen来创建一个队列并将其用于存放来自客户端的进入连接
> > > 4. 服务器通过系统调用accept来接收客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。
> > >
> > > **客户端**
> > >
> > > 1. 客户端应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接
> > > 2. 一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。

### 进程的状态

> ![img_oprSys_1](.\images\img_oprSys_1.png)
>
> - 就绪：进程已获得除处理器意外的所需资源，等待分配处理器资源
> - 运行：占用处理器资源运行，处于此状态的进程数小于等于CPU数
> - 阻塞：进程等待某种条件，在条件满足之前无法执行

### 进程调度策略有哪些

> ##### 批处理系统：
>
> **先来先服务** first-come first-servered（FCFS）
>
> > 按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定
>
> **最短作业优先** shortest job first （SJF）
>
> > 按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题
>
> **最短剩余时间优先** shortest remaining time next（SRTN）
>
> > 按剩余运行时间的顺序进行调度。（最短作业优先的抢占式版本）。吞吐量高，开销可能较大，提供好的响应时间，可能导致饥饿问题，对长进程不利
>
> **最高响应比优先** Highest Response Ratio Next （HRRN）
>
> > 响应比=1+等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好地平衡了长短进程。非抢占式，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题
>
> 
>
> ##### 交互式系统：
>
> 交互式系统有大量的用户交互操作，在该系统中调度算法的目的时快速地进行响应
>
> **时间片轮转**
>
> > 将所有就绪进程按照FCFS的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为段进程提供好的响应时间。若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证
>
> **优先级调度算法**
>
> > 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级
>
> **多级反馈队列调度算法**
>
> > 设置多个就绪队列123，优先级递减，时间片递增。只有等到优先级更高的队列时才会调度当前队列中的进程。如果进程用完了当前队列的时间片，该进程还未执行完，则会被移到下一队列。抢占式（时间片用完时）开销可能较大，对IO型进程有利，可能会出现饥饿问题。

### 什么叫优先级反转，怎么解决

> 高优先级的进程等待被一个低优先级进程占用资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程限制性。
>
> 具体描述：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的进程一直被挂起（由于资源被抢占，处于阻塞状态），直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级进程在中等优先级进程之后执行。
>
> **解决方案**：
>
> - 优先级天花板（priority ceiling）：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高级，这个优先级称为该资源的优先级天花板。
> - 优先级继承（priority inheritance）：当任务A申请共享资源S时，如果S正在被任务C占用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的优先级。

### 进程的异常控制流：陷阱、中断、异常和信号

> **陷阱**：陷阱是有意造成的”异常“，是执行一条指令的结果。陷阱是同步的，主要作用是实现系统调用。比如，进程可以执行`syscall n`指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，陷入到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行下一条指令。
>
> **中断**：中段由处理器外部的硬件产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括I/O设备发出的I/O中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。
>
> **异常**：异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而发生的错误情况，比如出发异常、缺页异常等。
>
> **信号**：信号是一种更高层的软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来通知进车给发生了某种系统事件。





## 其他问题

### 什么是I/O多路复用，怎么实现

> I/O多路复用（I/O Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。
>
> **从阻塞I/O到I/O多路复用：**
>
> > - 阻塞I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞I/O时，需要使用多线程来处理多个文件描述符。
> > - 多线程切换有一定的开销，因此引入非阻塞I/O。非阻塞I/O不会将进程挂起，调用时会立即返回成功或错误，因此可以在一个线程里轮询多个文件描述符是否就绪。
> > - 但是非阻塞I/O的缺点是：每次发起系统调用，只能检查一个文件描述符是否就绪，当文件描述符很多时，系统调用的成本很高。
> > - 因此引入多路复用，可以通过一次系统调用，检查多个文件描述符的状态。这是I/O多路复用的主要有点，相比于非阻塞I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。
> > - I/O多路复用相当于将遍历所有文件描述符、通过非阻塞I/O查看其是否就绪的过程从用户线程移到了内核中，由内核来负责轮询。
>
> 进程可以通过select、poll、epoll发起I/O多路复用的系统调用，这些系统调用都是同步阻塞的：如果传入的多个文件描述符中，有描述符就绪，则返回就绪的描述符；否则就阻塞调用进程，直到某个描述符准备就绪，或者阻塞时长超过设置的timeout后，再返回。I/O多路复用内部使用非阻塞I/O检查每个描述符的就绪状态。
>
> 如果timeout参数设置为Null，会无线阻塞直到某个描述符准备就绪；如果timeout参数设为0，会立即返回，不阻塞。