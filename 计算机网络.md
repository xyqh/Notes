# 计算机网络

## 概述

### OSI七层模型

> #### 简要概括
>
> - 物理层：底层数据传输。如网线，网卡标准。
>
> - 数据链路层：定义数据的基本格式。如何传输，如何标识，如网卡MAC地址。
>
> - 网络层：定义IP编址，定义路由功能。如不同设备的数据转发。
> - 传输层：端到端传输数据的基本功能。如TCP、UDP。
> - 会话层：控制应用程序之间会话能力。如不同软件数据分发给不同软件。
> - 标识层：数据格式标识，基本压缩加密功能。
> - 应用层：各种应用软件，包括Web应用。
>
> #### 说明
>
> - 在传输层，数据被称为**段**
> - 在网络层，数据被称为**包**
> - 在数据链路层，数据被称为**帧**
> - 在物理层，数据被称为**比特流**
>
> #### 总结
>
> - 网络七层模型是一个标准，而非实现。
> - 网络四层模型是一个实现的应用模型。
> - 网络四层模型由七层模型简化合并而来。

### TCP/IP协议

> 应用层：HTTP/FTP/SMTP/Telnet
>
> 传输层：TCP/UDP
>
> 网络层：ICMP/IP/IGMP
>
> 链路层：ARP/RARP



## HTTP

### 一次完整的HTTP请求过程中包括哪些内容

> 1. 域名解析
> 2. 发起TCP的3次握手
> 3. 建立TCP连接后发起http请求
> 4. 服务器响应http请求，浏览器得到html代码
> 5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）
> 6. 浏览器对页面进行渲染呈现给用户

### 什么是域名解析

> 通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或者主机名解析）。

### 什么是DNS

> DNS(Domain Name Syatem，域名系统)，因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便地访问互联网，而不用去记住能够被机器直接读取的IP数串。

### DNS的工作原理

> 将主机域名转换为ip地址，属于应用层协议，使用UDP传输。
>
> #### 过程：
>
> 浏览器缓存->系统缓存->路由器缓存->IPS服务器缓存->根域名服务器缓存->顶级域名服务器缓存->主域名服务器缓存
>
> 1. 当用户输入域名时，浏览器先检查自己的缓存中是否有这个域名映射的ip地址
> 2. 如果没有，则检查操作系统缓存（如windows中的hosts）中有没有解析结果
> 3. 如果没有，就找路由器缓存
> 4. 如果没有，则请求本地域名服务器解析
> 5. 如果没有，就请求根域名服务器解析
> 6. 如果没有，就请求顶级域名服务器解析
> 7. 然后返回一个主域名服务器的地址
> 8. 然后请求主域名服务器
> 9. 返回ip地址到本地域名服务器并缓存

### 为什么DNS区域传送（传输）用TCP

> #### 区域传送：
>
> 概念：一台备用服务器使用来自主服务器的数据刷新自己的域数据库
>
> 目的：做冗余备份，防止主服务器出现故障时DNS解析不可用
>
> 漏洞：主服务器不会对来请求的备用服务器做访问控制和身份验证
>
> 区域传送使用TCP是因为该事务对准确性要求高，而且会产生大于512字节的数据包，因此使用TCP协议。（UDP的数据包不能超过512字节）

### 为什么DNS域名解析用UDP

> 大多数情况下，DNS解析请求和响应都很小，使用UDP协议更加高效，虽然没有TCP可靠，但是速度快，消耗的系统资源更少，非常适合少量数据包的传输。
>
> 理论上，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

### DNS的负载均衡策略

> DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器。

### HTTP长连接和短连接的区别

> 在HTTP/1.0中默认使用短连接。即客户端和服务器每进行一次HTTP操作，就建立一次链接，任务结束就中段连接。（当html代码中包含js、css、图片等时，就会出现多次连接断开的情况，因为需要额外请求。）
>
> 从HTTP/1.1起，默认使用长连接，用以保持连接特性。一个TCP连接，多次HTTP请求。
>
> #### HTTP/2.0
>
> 二进制传输：在应用层和传输层之间增加了一个二进制分帧层。HTTP/2.0会将所有传输的信息分为更小的消息和帧，并采用二进制编码，其中HTTP/1.x的首部信息被封装到Header帧中。
>
> 多路复用：在HTTP/2.0中，帧是最小的数据单位，每个帧标识出该帧属于哪个**流**（**流**是多个帧组成的数据流）。而多路复用是指在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的标识知道该帧数据哪个请求。
>
> Header压缩：使用HPACK（HTTP／2.0头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。
>
> 服务器端提前响应：服务器可以对一个客户端请求发送多次相应。认为某些资源是客户端一定会请求的，所以服务器可以提前将资源相应给客户端，从而可以相对减少一些延迟时间。

### 一个TCP连接中可以一次发送多个HTTP请求吗（一起发3个请求，再3个响应一起接受）？

> HTTP/1.1不可以。单个TCP连接在同一时刻只能处理一个请求，即两个请求的声明周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重叠。
>
> 但是HTTP/1.1存在Pipelining技术可以完成这个多个请求同时发送，但由于浏览器默认关闭，所以可以认为这是不可行的。
>
> HTTP/2.0可以，因为有**多路复用**。

### HTTPS和HTTP的区别

> HTTP协议传输的数据都是明文，因此使用HTTP协议传输隐私信息非常不安全。
>
> HTTPS是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全

### 什么是SSL/TLS

> SSL代表安全套接字层，TLS代表传输层安全性协议。TLS安全性高于SSL。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。
>
> - 认证用户和服务器，确保数据发送到正确的客户机和服务器
> - 加密数据以防止数据中途被窃取
> - 维护数据的完整性，确保数据在传输过程中不被改变

### SSL是怎么保证安全的

> 1. 客户端与服务器建立TCP连接后，TLS握手从客户端发送”Client Hello“开始，此消息包含客户端支持的加密套件和一个随机数**rC**。
> 2. 服务端接受客户端的Client Hello消息后，响应Server Hello消息，此消息携带服务端从客户端提供的支持的加密套件列表中选择使用的解密套件，同时还会携带一个随机数**rS**。
> 3. 服务端向客户端发送证书，证书包含公钥和签名。
> 4. 客户端验证服务端发送的证书，验证通过后，假设选择加密套件是RSA_WITH_AES_128_CBC_SHA256，那么客户端要生成一个预主密钥**keyC**，然后从服务端发送的整数中提取公钥**pKey**，利用整数的公钥对预主密钥进行RSA加密，再发送给服务端。
> 5. 此时客户端开始根据**rC**+**rS**+**keyC**，生成主密钥**mKey**，**mKey**用于后续传输的数据进行加解密。
> 6. 接着，客户端向服务器发送Change Clipher Spec消息，告诉服务端，它后续将切换到使用协商好的加密密钥对数据进行加密再传输。同时也是跟Cline Key Exchange（此加密套件需要使用Client Key Exchange消息携带加密（用**mKey**加密）后的**keyC**）、Finished消息一起发送，Finished消息使用了该密钥（**mKey**）进行加密。**特别注意：顺序应该是Client Key Exchange、Change Clipher Spec、Finished**
> 7. 服务端收到Client Key Exchange消息后，从消息中提取加密过的**keyC**，然后拿证书的私钥解密获取**keyC**。
> 8. 服务端根据**rC**+**rS**+**keyC**形成主密钥**mKey**。
> 9. 服务端响应Change Clipher Spec消息，告诉客户端，服务端执行相同操作，后续将切换到使用协商好的加密密钥对数据进行加密再传输。同时也是跟Finished消息一起发送，Finished消息使用密钥（**mKey**）进行加密。



## TCP

### TCP报文结构

> #### TCP报头+TCP数据
>
> - **端口号**：用来标识一台主机的不同进程
>   - **源端端口号**：源端口和IP层解析出来的IP地址标识报文的发送地，同时也确定了报文的返回地址
>   - **对端端口号**：表明了该数据报是发送给接收方计算机的具体的应用程序
> - **序号和确认序号**
>   - **序号**：文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。例如：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400.所以序号确保了TCP传输的有序性。
>   - **确认序号**：即ack，知名下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误地收到。确认序号只有当ACK标识为1时才有效。比如收到一个报文段的序号为300，报文数据部分共有100字节，回复的ack就是400。
> - **数据偏移**：也叫做首部长度，以32比特位为长度单位
>   - 使用4个比特位，因为报文数据中含有可选项字段，所以TCP报头的长度是不确定的，出去可选项字段TCP的长度为20字节，4bit最大标识的数据为15*(32/8)=60，所以TCP报头最大长度为60字节。
> - **保留**：为将来定义新的用途保留，现在一般置0。
> - **标志位**：UGR,ACK,PSH,RST,SYN,FIN，六个标志位代表六个不同的功能。
>   - **UGR**：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针
>   - **ACK**：确认序号标志，为1时表示确认序号有效，为0则表示报文中不含有确认信息，忽略确认字段号
>   - **PSH**：push标志，为1时表示接收方在接受到数据以后，应尽快将这个报文交付到应用程序，而不是在缓冲区缓冲
>   - **RST**：重置连接标志，用于由主机崩溃或者其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求
>   - **SYN**：同步序号，用于建立连接过程中，在请求连接的时候，SYN=1和ACK=0表示该数据段没有捎带确认域，而连接应答需要捎带一个确认域，表示为SYN=1和ACK=1
>   - **FIN**：断开连接标志，用于释放连接，为1表示发送方已经没有数据发送，即关闭数据流
> - **窗口**：滑动窗口大小，用来告知发送端接收端的缓存大小，以此来控制发送端的发送速率，从而达到流量控制。窗口大小是一个16比特位的字段，因而窗口大小最大为65535字节。
> - **校验和**：奇偶校验，此校验和是对整个TCP报文段，包括TCP头部和TCP数据，以16位字节进行计算所得，由发送端计算和存储，并由接收端进行校验。
> - **紧急指针**：只有当URG标识为1时生效。紧急指针是一个正的偏移量，和顺序号字段中的值相加标识紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。
> - **选项和填充**：最常见的可选字段是最长报文的大小，又称为MSS，每个连接方式通常在通信的第一个报文段（也就是第一次握手的SYN报文）中指明这个选项，表示本端所能接收的最长报文段的长度。提示：选项长度不一定是32位的整数倍，所以要有填充位，即在这个字段中假如额外的零，以保证TCP头是32位的整数。
> - **数据部分**：TCP报文段中的数据部分是可选的，在建立连接和断开连接的时候，双方交换的报文段只有TCP的首部。在处理超时的许多情况中，也会发送不带任何数据的报文段。

### TCP三次握手流程

> #### 第一次握手：
>
> 客户端执行connect函数，向服务器发送连接请求报文段，这时TCP报文首部的SYN（同步位）=1。这时客户端进入SYN_SENT（同步已发送）状态，等待服务器的确认。
>
> ```
> "SYN=1,seq=x"
> ```
>
> 
>
> #### 第二次握手：
>
> 服务器收到请求报文段后，如果容易建立连接，则向A发送确认，在确认报文中SYN=1，ACK（确认序号标志）=1。这时服务器就进入了SYN_RCVD（同步收到）状态。客户端收到确认后会进入ESTABLISHED状态
>
> ```
> "SYN=1,ACK=1,seq=y,ack=x+1"
> ```
>
> 
>
> #### 第三次握手：
>
> 客户端在收到服务器的确认过后，还要给服务器发出确认，确认报文段将ACK置为1。服务器收到确认后，也进入了ESTABLISHED状态，此时TCP连接就建立完成了，随后客户端和服务器之间就可以传输数据。
>
> ```
> "ACK=1,seq=x+1,ack=y+1"
> ```
>
> 三次握手的结果就是服务器知道了客户端发送数据的序列号，客户端也知道服务器发送数据的序列号，并且双方都知道对方也知道了。

### TCP三次握手的状态类型

> **半连接状态**：发生在TCP三次握手过程中，客户端向服务器发起连接，服务器也进行了回应，但是客户端却不进行第三次握手
>
> **半打开状态**：在TCP连接中，如果某一端异常关闭，则该连接处于半打开状态
>
> **半关闭状态**：当TCP连接中，客户端向服务器发送FIN请求关闭，服务端回应ACK之后，并没有立即发送FIN给客户端，客户端就处于半关闭状态，此时客户端可以接受服务器发送的数据，但是客户端已经不能再向服务端发送数据

### 两次握手可以吗

> 假如只有两次握手，客户端请求连接且服务端也回应了，这时连接就建立了。假设此时客户端由于某种原因断开了，但是服务端还是在继续维护这个连接，浪费资源。至于为什么是三次，而不是四次五次，这是在确保连接和建立连接的效率上考虑的，最终确定三次是一个比较合适的次数。

### 在三次握手过程中，如果服务器一直收不到客户端的ACK消息（第三次握手）会发生什么

> 服务端会给每个半连接都设定一个定时器，如果超过时间还没有收到客户端的ACK消息，则重新发送一个SYN-ACK消息（第二次握手）给客户端，知道重试超过一定次数才会放弃。

### 初始序列号seq为什么要随机初始化

> 出于网络安全的考虑。如果是固定初始化序列号，那么第三方容易伪造序列号进行攻击。

### TCP四次挥手流程

> #### 第一次挥手：
>
> 客户端进程先发出连接释放报文，并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT_1（终止等待1）状态。
>
> #### 第二次挥手：
>
> 服务器收到连接释放报文后发出确认，把确认报文段首部ACK置1。然后进入CLOSE_WAIT（等待关闭状态）。客户端收到服务端的确认后就进去FIN_WAIT_2（终止等待2）状态，等待服务端发出的连接释放报文。此时的TCP连接处于半关闭状态，即客户端已经没有数据要发送了，但是服务端若发送数据，客户端仍要接受。也就是说，从服务端到客户端这个方向的连接并没有关闭，这个状态可能会持续一段时间。
>
> #### 第三次挥手：
>
> 如果服务端没有要想客户端发送的数据了，其应用进程就通知TCP释放连接，这是服务端发出连接释放报文。这时服务端就进入LAST_ACK（最后确认）状态，等待客户端的确认。
>
> #### 第四次挥手：
>
> 客户端收到服务端的连接释放报文后，必须对此发出确认，在确认报文段中把ACK置1。然后客户端进入到TIME_WAIT（时间等待）状态。
>
> **注意：**
>
> - 现在TCP连接还没有释放掉，必须经过时间等待计时器设置的2MSL后，客户端才进入CLOSED状态。MSL成为最长报文段寿命，即报文段存活最大时间。
> - 服务端收到客户端的确认报文段后就会进入CLOSED状态。服务端在撤销相应的传输控制快TCB后，就结束了这次的TCP连接，服务端结束连接的时间要比客户端早一些。

### 为什么握手是三次而挥手需要四次

> 建立连接意味着双端都做好了准备。而断开连接的前提是双方都建立了连接，建立连接之后双方就可能会存在数据传输，而断开连接只意味着其中一方做好了断开的准备，另一方未必做好了准备，因此另一方会先回复ACK报文使客户端进入半关闭状态，之后等到服务端做好了准备（即把要发送的报文都发送完毕）才会发送第三次挥手（服务端的FIN=1），因此可以视为是对应连接中的第二次握手需要在断开中分为两步进行处理。

### CLOSE_WAIT状态有什么影响

> 当服务端收到客户端的断开连接请求并回复了ACK后，会进入CLOSE_WAIT状态，此时TCP处于半关闭状态。
>
> CLOSE_WAIT状态一直存在说明服务器没有调用close以及回复FIN=1报文段，而服务端长期保持这个状态，就会一直占用这大量的socket文件描述符，大量的CLOSE_WAIT状态存在就会导致文件描述符被占用，一些客户端无法连接。

### socket中的close是一次就关闭的吗？半关闭状态是怎么产生的

> 使用socket的close终止一个连接，它只是减少了文件描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0的时候才关闭连接。而客户端的半关闭状态是指收到服务端的ACK之后，此时客户端已经不向服务端发送数据了，但还是会接受服务端发来的数据。

### 如果已经建立了连接，但是客户端突发故障怎么办

> TCP设有一个保活计时器，服务端每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置的是2个小时，若2个小时还没有收到客户端的任何数据，服务端就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文段仍然没有反应，服务端就认为客户端除了故障，接着就关闭连接（应该是直接关闭，而不是四次挥手流程）。

### 为什么需要TIME_WAIT状态

> TIME_WAIT状态是指主动关闭的一端接收到对端发送的FIN报文段后进入的状态。
>
> 假如强行终止其中一端，但是TCP协议层的连接并没有断开，因此不能再次监听同样的端口。
>
> - 为了保证客户端发送的最后一个ACK报文能够到达服务端，即可靠的TCP连接考虑到这个ACK报文可能丢失，因而使其处于LAST_ACK状态的服务端收不到释放连接的ACK确认，那么服务端就会重传一次FIN释放报文，重新启动2MSL。最后双端都正常进入CLOSE状态。如果客户端在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文后直接释放连接，那么就无法收到服务端重传的FIN报文段，因而也不会再发送一次确认报文段，这样服务端就没有办法按正常步骤进入CLOSE状态。
> - 为了防止失效的连接请求报文段出现在本连接中客户端在发送完最后一个ACK报文段之后。再经过2MSL就可以使本连接持续的时间内产生的所有报文段从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 为什么是2MSL

> 2MSL的时间是客户端收到FIN报文后发送给ACK报文后开始计时的，考虑到重传的因素，那么服务端就需要再次给客户端发送FIN+ACK报文。
>
> 保证在两个传输方向上的尚未被接收或迟到的报文都消失，理论上保证最后一个报文可靠达到，就需要2MSL，一个方向1MSL。

### TIME_WAIT会带来哪些问题

> - 作为服务器，短时间内关闭了大量的客户端连接，就会造成服务端上出现大量的TIME_WAIT连接，占用大量的tuple（源IP地址，目的IP地址、协议号、源端口、目的端口），严重消耗服务端的资源
> - 作为客户端，短时间内大量的断开连接，会大量消耗客户端机器的端口，毕竟端口只有65535个，端口耗尽了，后续就无法启用新的连接

### 怎么解决TIME_WAIT状态引起的bind失败问题

> 因为服务端的TCP连接没有完全断开之前是不允许重新监听的，这在某些情况下是不合理的。因为一般我们的服务端都会处理大量的客户端的连接，由于请求量很大所以可能导致TIME_WAIT的连接数很多，每个连接都会占用一个通信tuple。
>
> 所以我们可以使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但是IP地址不同的多个socket描述符。加上之后，即使终止其中一个端之后也可以马上启动并连接。

### 三次挥手可以吗

> 可以，当客户端发送FIN报文后，服务端收到之后且刚好处理完了所有的数据，就会一起发送FIN+ACK报文，这样就是三次挥手。

### TCP如何保证传输可靠性

> #### 校验和：
>
> TCP校验和是一个端到端的校验和，由发送端计算，接收端验证。目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃。（之后干什么不知道，可能就什么都不干了）
>
> TCP在计算校验和时，会在TCP首部加上一个12字节的伪首部。校验和总共计算3部分：TCP伪首部、TCP首部、TCP数据。
>
> - TCP校验和覆盖TCP首部和TCP数据，而IP首部中的校验和只覆盖IP的首部，不覆盖IP数据报中的任何数据。
> - TCP的校验和是必需的，而UDP的校验和是可选的。
> - TCP和UDP计算校验和时，都要加上一个12字节的伪首部。
>
> 计算方式：在数据传输的过程中，将发送的数据段都当作一个16位的整数。将这些整数加起来，并且前面的仅为不能丢弃，补在后面，最后取反，得到校验和。（**取反求和**和**求和取反**是一样的）
>
> 发送方：在发送数据之前计算校验和，并进行校验和填充。
>
> 接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行对比。
>
> 注意：校验和不一致时数据一定有误。（校验和一致时数据不一定正确）
>
> 例子：
>
> ```
> 08 00 4d 5a 00 01 00 01 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 61 62 63 64 65 66 67 68 69
> 其中校验和是“4d 5a”
> 1、将校验和字段置为0
> 08 00 00 00 00 01 00 01 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 61 62 63 64 65 66 67 68 69
> 2、把它们两个字节（16bit）组成一组，依次以二进制相加（求和）直至得到结果，这里我就不用二进制表示了，直接用十六进制好看，但要清楚计算机内部是利用二进制处理的。
> 0800 + 0000 + 0001 + 0001 + 6162 + 6364 + 6566 + 6768 + 696a + 6b6c + 6d6e + 6f70 + 7172 + 7374 + 7576 + 7761 + 6263 + 6465 + 6667 + 6869 = 6b29f = b2a5（处理溢出位，即b29f + 6 = b2a5）
> 3、取反
> ~b2a5 & 0xffff --> 4d5a
> ```
>
> #### 序列号与确认应答：
>
> 序列号（Seq）：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
>
> 确认应答（ack）：TCP传输的过程中发，每次接收方收到数据后，都会对传输发进行确认应答，也就是发送ACK报文，这个报文中带有对应的确认序列号（ack），告诉发送方接收到了哪些数据，下一次的数据从哪里发。
>
> 只要发送端有一个包传输，接收端都要回应确认包，假如发送端没有收到确认包，就会重发。
>
> #### 超时重传：
>
> 在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么处理？
>
> 首先，发送方没有接收到响应的ACK报文原因有两点：
>
> 1. 数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。
> 2. 接收方接收到了数据，但是发送的ACK报文响应由于网络原因丢包了。
>
> TCP在解决这个问题时引入了一个新的机制，叫做超时重传机制。发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。这时，根据以上两种原因，接收端有不同的处理：
>
> 1. 接收端收到二次重发的数据，进行ACK应答。
> 2. 接收端发现数据已存在，那么直接丢弃，但还会进行ACK应答。
>
> 关于超时重传的等待时间：略大于**RTT（往返时间）+抖动值（由于网络原因，时间会有偏差）**
>
> #### 连接管理：
>
> 就是之前提到的三次握手和四次挥手
>
> #### 流量控制（滑动窗口控制）：
>
> 接收端在接收到数据后，对其进行处理，但是由于发送方发送速度过快，导致接收端的接受缓冲区很快就填满了。此时如果发送端继续发送数据，那么接下来的数据都会丢包，继而导致丢包后的一系列处理，超时重传之类的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。
>
> 关于流量控制，需要引入一个**滑动窗口**（分为**拥塞窗口（发送窗口）**和**接收窗口**）的概念：
>
> 在TCP协议的报头数据中，有一个16字段的窗口大小，窗口字段就是用来实现滑动窗口的。窗口的大小实际就是接收端接受数据缓冲区的剩余大小。这个数字越大， 证明接收端的接收缓冲区剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的及时窗口大小填入，并跟随ACK报文一起发送过去。而发送端根据ACK报文中的窗口大小改变自己的发送速度。如果接收端的窗口大小为0，那么发送方将停止发送数据。另外，发送端会定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。
>
> 注意：16位的窗口大小最多能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16位窗口字段的值左移M位。每移一位，扩大两倍。
>
> 为什么会出现滑动窗口：
>
> 在确认应答策略中，对于每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样有一个比较大的缺点就是性能比较差，尤其是数据往返的时间长的时候。使用滑动窗口就可以一次发送多条数据。
>
> 滑动窗口原理：
>
> 1. 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即不需要接收端的应答，可以一次连续发送的数据。假设为M。
> 2. 发送前M段时，无法ACK应答，直接发送。
> 3. 收到第1个ACK应答时，滑动窗口向后移动，继续发送第M+1段数据。滑动窗口前是已经确认应答的数据，滑动窗口中是待确认应答的包，窗口后是未发送的包。
> 4. 操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有哪些数据没有应答，只有确认应答过的数据，才能从缓冲区删除。
> 5. 窗口越大，网络吞吐率越高。
>
> #### 拥塞控制：
>
> TCP传输的过程中，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果再发送大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，以及大量的超时重传，严重影响传输。
>
> 于是就产生了**拥塞控制**的概念，它的主要机制包括：**慢开始（慢启动）**、**拥塞避免**、**快重传**和**快恢复**。
>
> ##### 慢开始和拥塞避免
>
> 发送方维持一个拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞成都，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。
>
> 发送方控制拥塞窗口的原则是：只要网络没有出现阻塞，拥塞窗口就再增大一些，以便把更多的数据发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的数据。
>
> 慢开始的思路就是：一开始不要发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
>
> 慢开始算法：通常在刚开始发送报文时，先把拥塞窗口cwnd设置为1。而在每收到一个对新的报文的确认后，把拥塞窗口增加至原来的2倍。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使数据注入到网络的速率更加合理。
>
> 每经过一个传输轮次，拥塞窗口cwnd就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文都连续发送出去，并收到了对已发送的最后一个字节的确认。
>
> 另外慢开始的**慢**指的不是cwnd的增长速率，而是开始发送时的cwnd较小。
>
> 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：
>
> 1. 当cwnd<ssthresh时，使用上述的慢开始算法
> 2. 当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法
> 3. 当cwnd=ssthresh时，两者都可以用
>
> 拥塞避免算法：让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。
>
> 无论是在慢开始还是在拥塞避免阶段，只要发送方判断网络出现拥塞（指没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口重新设置为1，执行慢开始算法。
>
> ##### 快重传和快恢复
>
> 拥塞避免是不是快重传的情况下的处理。快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
>
> 假定发送方连续发送M1-7的报文，接收方收到后回应了M1-2的确认，但是没有收到M3的报文，直接收到了M4的报文，这时直接回复M2的确认（重复确认），对M5-6也是同样的处理，这时接收方就收到了M2的1次正常确认和3次重复确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必等到M3的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。
>
> 与快重传配合使用的还有快恢复：
>
> 1. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这时为了预防网络发生拥塞，但是接下来不是执行慢开始算法。
> 2. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同的是，现在不执行慢开始算法（不把cwnd设置为1），而是把cwnd设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。
> 3. **另外地**，也有的快恢复算法设置的cwnd是ssthresh+3 X MSS（最长报文大小）。这样做的理由是既然发送方收到三个重复的确认，就表明有三个报文已经离开了网络。这三个报文不再消耗网络的资源，而是停留在接收方的缓存中。可见现在网络中并不是堆积了报文而是减少了三个报文。因此可以适当把拥塞窗口扩大。
>
> 在采用快恢复算法时，慢开始算法只有在建立TCP连接和网络超时时才使用。
>
> 接收方根据自己的接受能力设定了接受窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。
>
> ```
> 发送方窗口的上限值 = Min[rwnd, cwnd]
> ```

### TCP分包和粘包

> 首先明确一点：TCP是面向连接的、可靠的字节流协议，并非面向报文。对于应用层提交到传输层的数据，不一定会立即被打包成一个TCP报文，也不一定会单独打包成为一个TCP报文。
>
> 因此就产生了分包和粘包的问题。
>
> 分包：接收端读取数据时候数据分批到达，造成一次发送多次读取。
>
> 原因：
>
> 1. TCP是以段为单位发送数据的，建立TCP连接后，有一个最大消息长度（MSS）。如果应用层数据包超过MSS，就一定会把数据包拆分，分成两个段来发送。
> 2. 路由器有一个MTU（最大传输单元），一般是1500字节，除去IP头部20字节，再除去TCP头部20字节，所以一般TCP的MSS为1460字节。
>
> 粘包：发送端发送了几次数据，接收端一次读取了所有数据，造成多次发送一次读取。
>
> 原因：
>
> 1. TCP为了提高网络的利用率，会使用Nagle算法，指发送端即使有要发送的数据，如果很少的话，会延迟发送。
> 2. 如果应用层给TCP传送数据很快的话，就会把两个应用层数据包“粘”在一起，TCP最后只发一个TCP数据包给接收端。
>
> 解决方案：
>
> 1. 通过换行符来区分每个包
> 2. 通过特殊分隔符来区分每个包
> 3. 通过定长的报文来分包（应用层提交数据的时候就定长）
> 4. 根据包头部定义的长度来区分包



## UDP

### UDP报文结构

> 由首部+数据部分组成，其中首部：
>
> - 源端口：源端端口。在需要对方回信时选用，不需要时可用0填充。
>
> - 目的端口：目的端口号。在终点交付报文时使用。
>
> - 长度：UDP用户数据报的长度，其最小值是8（即仅有首部部分），单位：字节。
>
> - 校验和：检测数据在传输过程中是否出错，出错就丢弃。
>
> 校验和计算：12字节伪首部+8字节UDP首部+8字节数据求和之后取反得到校验和。
>
> 伪首部组成：总共12字节。源端口+目的端口+协议类型（TCP为6，UDP为17，占1字节，需要补充1字节长度全0）+UDP长度（头部8字节+数据包长度）
>
> |            | 源IP地址（32位）     |                 |
> | ---------- | -------------------- | --------------- |
> |            | 目的地IP地址（32位） |                 |
> | 0x0（8位） | 协议类型（8位）      | UDP长度（16位） |

### UDP怎么实现可靠传输

> 1. 应用层确认机制：在应用层上，可以实现自定义的确认机制。发送方在发送数据后等待接收方的确认消息，如果在一定时间内未收到确认，则重新发送数据。
> 2. 数据校验和重传：已经有校验和了。
> 3. 序列号和确认号：类似TCP的序列号和确认号机制，发送方给每个数据包分配唯一的序列号，接收方都到数据后发送确认消息，并在其中包含确认号。发送方根据确认好判断哪些数据包已经被成功接收，可以进行响应的重传
> 4. 流量控制和拥塞控制。





## UDP和TCP的区别

> |                | TCP                                                          | UDP                                                          |
> | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | 连接           | 面向连接，先连接再传数据                                     | 不需要连接，直接传数据                                       |
> | 服务对象       | 一对一                                                       | 一对多，多对一，多对多                                       |
> | 可靠性         | 可靠交付                                                     | 最大努力（不可靠）交付                                       |
> | 流量和拥塞控制 | 都有                                                         | 都没有，网络拥堵了也不影响我的发送速率                       |
> | 首部开销       | 20字节（有选项字段的话会更多）                               | 8字节                                                        |
> | 传输方式       | 流式传输，没有边界，有分包和粘包问题                         | 包传输，没有边界，可能丢包和乱序                             |
> | 分片不同       | TCP的数据大小大于MSS，就会在传输层分片，目标主机收到后在传输层进行组装，如果中间分片丢失，只需要重传中间分片。 | UDP的数据大小如果大于MTU，就会在IP层（网络层）分片，目标主机收到后在IP层组装，接着再传给传输层 |